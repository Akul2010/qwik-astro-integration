{
  "resolvedId": "/home/jackshelton/dev/open-source/astro-qwik/node_modules/.pnpm/@builder.io+qwik@1.2.11_undici@5.24.0/node_modules/@builder.io/qwik/server.mjs",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/**\n * @license\n * @builder.io/qwik/server 1.2.11\n * Copyright Builder.io, Inc. All Rights Reserved.\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/BuilderIO/qwik/blob/main/LICENSE\n */\nvar __require = /* @__PURE__ */ ((x) => typeof require !== \"undefined\" ? require : typeof Proxy !== \"undefined\" ? new Proxy(x, {\n  get: (a, b) => (typeof require !== \"undefined\" ? require : a)[b]\n}) : x)(function(x) {\n  if (typeof require !== \"undefined\")\n    return require.apply(this, arguments);\n  throw Error('Dynamic require of \"' + x + '\" is not supported');\n});\n\n// packages/qwik/src/server/index.ts\nimport { setPlatform as setPlatform2 } from \"@builder.io/qwik\";\n\n// packages/qwik/src/server/platform.ts\nimport { setPlatform } from \"@builder.io/qwik\";\nfunction createPlatform(opts, resolvedManifest) {\n  const mapper = resolvedManifest?.mapper;\n  const mapperFn = opts.symbolMapper ? opts.symbolMapper : (symbolName) => {\n    if (mapper) {\n      const hash = getSymbolHash(symbolName);\n      const result = mapper[hash];\n      if (!result) {\n        const isRegistered = globalThis.__qwik_reg_symbols?.has(hash);\n        if (isRegistered) {\n          return [symbolName, \"_\"];\n        }\n        console.error(\"Cannot resolve symbol\", symbolName, \"in\", mapper);\n      }\n      return result;\n    }\n  };\n  const serverPlatform = {\n    isServer: true,\n    async importSymbol(_containerEl, url, symbolName) {\n      const hash = getSymbolHash(symbolName);\n      const regSym = globalThis.__qwik_reg_symbols?.get(hash);\n      if (regSym) {\n        return regSym;\n      }\n      let modulePath = String(url);\n      if (!modulePath.endsWith(\".js\")) {\n        modulePath += \".js\";\n      }\n      const module = __require(modulePath);\n      if (!(symbolName in module)) {\n        throw new Error(`Q-ERROR: missing symbol '${symbolName}' in module '${modulePath}'.`);\n      }\n      return module[symbolName];\n    },\n    raf: () => {\n      console.error(\"server can not rerender\");\n      return Promise.resolve();\n    },\n    nextTick: (fn) => {\n      return new Promise((resolve) => {\n        setTimeout(() => {\n          resolve(fn());\n        });\n      });\n    },\n    chunkForSymbol(symbolName) {\n      return mapperFn(symbolName, mapper);\n    }\n  };\n  return serverPlatform;\n}\nasync function setServerPlatform(opts, manifest) {\n  const platform = createPlatform(opts, manifest);\n  setPlatform(platform);\n}\nvar getSymbolHash = (symbolName) => {\n  const index = symbolName.lastIndexOf(\"_\");\n  if (index > -1) {\n    return symbolName.slice(index + 1);\n  }\n  return symbolName;\n};\n\n// packages/qwik/src/server/utils.ts\nfunction createTimer() {\n  if (typeof performance === \"undefined\") {\n    return () => 0;\n  }\n  const start = performance.now();\n  return () => {\n    const end = performance.now();\n    const delta = end - start;\n    return delta / 1e6;\n  };\n}\nfunction getBuildBase(opts) {\n  let base = opts.base;\n  if (typeof opts.base === \"function\") {\n    base = opts.base(opts);\n  }\n  if (typeof base === \"string\") {\n    if (!base.endsWith(\"/\")) {\n      base += \"/\";\n    }\n    return base;\n  }\n  return \"/build/\";\n}\nvar versions = {\n  qwik: \"1.2.11\",\n  qwikDom: \"2.1.19\"\n};\n\n// packages/qwik/src/server/render.ts\nimport { _renderSSR, Fragment as Fragment2, jsx as jsx2, _pauseFromContexts } from \"@builder.io/qwik\";\nimport { isDev } from \"@builder.io/qwik/build\";\n\n// packages/qwik/src/server/scripts.ts\nvar QWIK_LOADER_DEFAULT_MINIFIED = '((e,t)=>{const n=\"__q_context__\",o=window,s=new Set,i=t=>e.querySelectorAll(t),a=(e,t,n=t.type)=>{i(\"[on\"+e+\"\\\\\\\\:\"+n+\"]\").forEach((o=>f(o,e,t,n)))},r=(e,t)=>e.getAttribute(t),l=t=>{if(void 0===t._qwikjson_){let n=(t===e.documentElement?e.body:t).lastElementChild;for(;n;){if(\"SCRIPT\"===n.tagName&&\"qwik/json\"===r(n,\"type\")){t._qwikjson_=JSON.parse(n.textContent.replace(/\\\\\\\\x3C(\\\\/?script)/g,\"<$1\"));break}n=n.previousElementSibling}}},c=(e,t)=>new CustomEvent(e,{detail:t}),f=async(t,o,s,i=s.type)=>{const a=\"on\"+o+\":\"+i;t.hasAttribute(\"preventdefault:\"+i)&&s.preventDefault();const c=t._qc_,f=null==c?void 0:c.li.filter((e=>e[0]===a));if(f&&f.length>0){for(const e of f)await e[1].getFn([t,s],(()=>t.isConnected))(s,t);return}const b=r(t,a);if(b){const o=t.closest(\"[q\\\\\\\\:container]\"),i=new URL(r(o,\"q:base\"),e.baseURI);for(const a of b.split(\"\\\\n\")){const r=new URL(a,i),c=r.hash.replace(/^#?([^?[|]*).*$/,\"$1\")||\"default\",f=performance.now(),b=import(\\n/* @vite-ignore */\\nr.href.split(\"#\")[0]);l(o);const p=(await b)[c],u=e[n];if(t.isConnected)try{e[n]=[t,s,r],d(\"qsymbol\",{symbol:c,element:t,reqTime:f}),await p(s,t)}finally{e[n]=u}}}},d=(t,n)=>{e.dispatchEvent(c(t,n))},b=e=>e.replace(/([A-Z])/g,(e=>\"-\"+e.toLowerCase())),p=async e=>{let t=b(e.type),n=e.target;for(a(\"-document\",e,t);n&&n.getAttribute;)await f(n,\"\",e,t),n=e.bubbles&&!0!==e.cancelBubble?n.parentElement:null},u=e=>{a(\"-window\",e,b(e.type))},w=()=>{var n;const a=e.readyState;if(!t&&(\"interactive\"==a||\"complete\"==a)&&(t=1,d(\"qinit\"),(null!=(n=o.requestIdleCallback)?n:o.setTimeout).bind(o)((()=>d(\"qidle\"))),s.has(\"qvisible\"))){const e=i(\"[on\\\\\\\\:qvisible]\"),t=new IntersectionObserver((e=>{for(const n of e)n.isIntersecting&&(t.unobserve(n.target),f(n.target,\"\",c(\"qvisible\",n)))}));e.forEach((e=>t.observe(e)))}},q=(e,t,n,o=!1)=>e.addEventListener(t,n,{capture:o,passive:!1}),v=t=>{for(const n of t)s.has(n)||(q(e,n,p,!0),q(o,n,u),s.add(n))};if(!e.qR){const t=o.qwikevents;Array.isArray(t)&&v(t),o.qwikevents={push:(...e)=>v(e)},q(e,\"readystatechange\",w),w()}})(document);';\nvar QWIK_LOADER_DEFAULT_DEBUG = '(() => {\\n    ((doc, hasInitialized) => {\\n        const win = window;\\n        const events =  new Set;\\n        const querySelectorAll = query => doc.querySelectorAll(query);\\n        const broadcast = (infix, ev, type = ev.type) => {\\n            querySelectorAll(\"[on\" + infix + \"\\\\\\\\:\" + type + \"]\").forEach((target => dispatch(target, infix, ev, type)));\\n        };\\n        const getAttribute = (el, name) => el.getAttribute(name);\\n        const resolveContainer = containerEl => {\\n            if (void 0 === containerEl._qwikjson_) {\\n                let script = (containerEl === doc.documentElement ? doc.body : containerEl).lastElementChild;\\n                while (script) {\\n                    if (\"SCRIPT\" === script.tagName && \"qwik/json\" === getAttribute(script, \"type\")) {\\n                        containerEl._qwikjson_ = JSON.parse(script.textContent.replace(/\\\\\\\\x3C(\\\\/?script)/g, \"<$1\"));\\n                        break;\\n                    }\\n                    script = script.previousElementSibling;\\n                }\\n            }\\n        };\\n        const createEvent = (eventName, detail) => new CustomEvent(eventName, {\\n            detail: detail\\n        });\\n        const dispatch = async (element, onPrefix, ev, eventName = ev.type) => {\\n            const attrName = \"on\" + onPrefix + \":\" + eventName;\\n            element.hasAttribute(\"preventdefault:\" + eventName) && ev.preventDefault();\\n            const ctx = element._qc_;\\n            const qrls = null == ctx ? void 0 : ctx.li.filter((li => li[0] === attrName));\\n            if (qrls && qrls.length > 0) {\\n                for (const q of qrls) {\\n                    await q[1].getFn([ element, ev ], (() => element.isConnected))(ev, element);\\n                }\\n                return;\\n            }\\n            const attrValue = getAttribute(element, attrName);\\n            if (attrValue) {\\n                const container = element.closest(\"[q\\\\\\\\:container]\");\\n                const base = new URL(getAttribute(container, \"q:base\"), doc.baseURI);\\n                for (const qrl of attrValue.split(\"\\\\n\")) {\\n                    const url = new URL(qrl, base);\\n                    const symbolName = url.hash.replace(/^#?([^?[|]*).*$/, \"$1\") || \"default\";\\n                    const reqTime = performance.now();\\n                    const module = import(\\n                    /* @vite-ignore */\\n                    url.href.split(\"#\")[0]);\\n                    resolveContainer(container);\\n                    const handler = (await module)[symbolName];\\n                    const previousCtx = doc.__q_context__;\\n                    if (element.isConnected) {\\n                        try {\\n                            doc.__q_context__ = [ element, ev, url ];\\n                            emitEvent(\"qsymbol\", {\\n                                symbol: symbolName,\\n                                element: element,\\n                                reqTime: reqTime\\n                            });\\n                            await handler(ev, element);\\n                        } finally {\\n                            doc.__q_context__ = previousCtx;\\n                        }\\n                    }\\n                }\\n            }\\n        };\\n        const emitEvent = (eventName, detail) => {\\n            doc.dispatchEvent(createEvent(eventName, detail));\\n        };\\n        const camelToKebab = str => str.replace(/([A-Z])/g, (a => \"-\" + a.toLowerCase()));\\n        const processDocumentEvent = async ev => {\\n            let type = camelToKebab(ev.type);\\n            let element = ev.target;\\n            broadcast(\"-document\", ev, type);\\n            while (element && element.getAttribute) {\\n                await dispatch(element, \"\", ev, type);\\n                element = ev.bubbles && !0 !== ev.cancelBubble ? element.parentElement : null;\\n            }\\n        };\\n        const processWindowEvent = ev => {\\n            broadcast(\"-window\", ev, camelToKebab(ev.type));\\n        };\\n        const processReadyStateChange = () => {\\n            var _a;\\n            const readyState = doc.readyState;\\n            if (!hasInitialized && (\"interactive\" == readyState || \"complete\" == readyState)) {\\n                hasInitialized = 1;\\n                emitEvent(\"qinit\");\\n                (null != (_a = win.requestIdleCallback) ? _a : win.setTimeout).bind(win)((() => emitEvent(\"qidle\")));\\n                if (events.has(\"qvisible\")) {\\n                    const results = querySelectorAll(\"[on\\\\\\\\:qvisible]\");\\n                    const observer = new IntersectionObserver((entries => {\\n                        for (const entry of entries) {\\n                            if (entry.isIntersecting) {\\n                                observer.unobserve(entry.target);\\n                                dispatch(entry.target, \"\", createEvent(\"qvisible\", entry));\\n                            }\\n                        }\\n                    }));\\n                    results.forEach((el => observer.observe(el)));\\n                }\\n            }\\n        };\\n        const addEventListener = (el, eventName, handler, capture = !1) => el.addEventListener(eventName, handler, {\\n            capture: capture,\\n            passive: !1\\n        });\\n        const push = eventNames => {\\n            for (const eventName of eventNames) {\\n                if (!events.has(eventName)) {\\n                    addEventListener(doc, eventName, processDocumentEvent, !0);\\n                    addEventListener(win, eventName, processWindowEvent);\\n                    events.add(eventName);\\n                }\\n            }\\n        };\\n        if (!doc.qR) {\\n            const qwikevents = win.qwikevents;\\n            Array.isArray(qwikevents) && push(qwikevents);\\n            win.qwikevents = {\\n                push: (...e) => push(e)\\n            };\\n            addEventListener(doc, \"readystatechange\", processReadyStateChange);\\n            processReadyStateChange();\\n        }\\n    })(document);\\n})();';\nvar QWIK_LOADER_OPTIMIZE_MINIFIED = '((e,t)=>{const n=\"__q_context__\",o=window,s=new Set,i=t=>e.querySelectorAll(t),a=(e,t,n=t.type)=>{i(\"[on\"+e+\"\\\\\\\\:\"+n+\"]\").forEach((o=>f(o,e,t,n)))},r=(e,t)=>e.getAttribute(t),l=t=>{if(void 0===t._qwikjson_){let n=(t===e.documentElement?e.body:t).lastElementChild;for(;n;){if(\"SCRIPT\"===n.tagName&&\"qwik/json\"===r(n,\"type\")){t._qwikjson_=JSON.parse(n.textContent.replace(/\\\\\\\\x3C(\\\\/?script)/g,\"<$1\"));break}n=n.previousElementSibling}}},c=(e,t)=>new CustomEvent(e,{detail:t}),f=async(t,o,s,i=s.type)=>{const a=\"on\"+o+\":\"+i;t.hasAttribute(\"preventdefault:\"+i)&&s.preventDefault();const c=t._qc_,f=null==c?void 0:c.li.filter((e=>e[0]===a));if(f&&f.length>0){for(const e of f)await e[1].getFn([t,s],(()=>t.isConnected))(s,t);return}const b=r(t,a);if(b){const o=t.closest(\"[q\\\\\\\\:container]\"),i=new URL(r(o,\"q:base\"),e.baseURI);for(const a of b.split(\"\\\\n\")){const r=new URL(a,i),c=r.hash.replace(/^#?([^?[|]*).*$/,\"$1\")||\"default\",f=performance.now(),b=import(\\n/* @vite-ignore */\\nr.href.split(\"#\")[0]);l(o);const p=(await b)[c],u=e[n];if(t.isConnected)try{e[n]=[t,s,r],d(\"qsymbol\",{symbol:c,element:t,reqTime:f}),await p(s,t)}finally{e[n]=u}}}},d=(t,n)=>{e.dispatchEvent(c(t,n))},b=e=>e.replace(/([A-Z])/g,(e=>\"-\"+e.toLowerCase())),p=async e=>{let t=b(e.type),n=e.target;for(a(\"-document\",e,t);n&&n.getAttribute;)await f(n,\"\",e,t),n=e.bubbles&&!0!==e.cancelBubble?n.parentElement:null},u=e=>{a(\"-window\",e,b(e.type))},w=()=>{var n;const a=e.readyState;if(!t&&(\"interactive\"==a||\"complete\"==a)&&(t=1,d(\"qinit\"),(null!=(n=o.requestIdleCallback)?n:o.setTimeout).bind(o)((()=>d(\"qidle\"))),s.has(\"qvisible\"))){const e=i(\"[on\\\\\\\\:qvisible]\"),t=new IntersectionObserver((e=>{for(const n of e)n.isIntersecting&&(t.unobserve(n.target),f(n.target,\"\",c(\"qvisible\",n)))}));e.forEach((e=>t.observe(e)))}},q=(e,t,n,o=!1)=>e.addEventListener(t,n,{capture:o,passive:!1}),v=t=>{for(const n of t)s.has(n)||(q(e,n,p,!0),q(o,n,u),s.add(n))};if(!e.qR){const t=o.qwikevents;Array.isArray(t)&&v(t),o.qwikevents={push:(...e)=>v(e)},q(e,\"readystatechange\",w),w()}})(document);';\nvar QWIK_LOADER_OPTIMIZE_DEBUG = '(() => {\\n    ((doc, hasInitialized) => {\\n        const win = window;\\n        const events = new Set;\\n        const querySelectorAll = query => doc.querySelectorAll(query);\\n        const broadcast = (infix, ev, type = ev.type) => {\\n            querySelectorAll(\"[on\" + infix + \"\\\\\\\\:\" + type + \"]\").forEach((target => dispatch(target, infix, ev, type)));\\n        };\\n        const getAttribute = (el, name) => el.getAttribute(name);\\n        const resolveContainer = containerEl => {\\n            if (void 0 === containerEl._qwikjson_) {\\n                let script = (containerEl === doc.documentElement ? doc.body : containerEl).lastElementChild;\\n                while (script) {\\n                    if (\"SCRIPT\" === script.tagName && \"qwik/json\" === getAttribute(script, \"type\")) {\\n                        containerEl._qwikjson_ = JSON.parse(script.textContent.replace(/\\\\\\\\x3C(\\\\/?script)/g, \"<$1\"));\\n                        break;\\n                    }\\n                    script = script.previousElementSibling;\\n                }\\n            }\\n        };\\n        const createEvent = (eventName, detail) => new CustomEvent(eventName, {\\n            detail: detail\\n        });\\n        const dispatch = async (element, onPrefix, ev, eventName = ev.type) => {\\n            const attrName = \"on\" + onPrefix + \":\" + eventName;\\n            element.hasAttribute(\"preventdefault:\" + eventName) && ev.preventDefault();\\n            const ctx = element._qc_;\\n            const qrls = null == ctx ? void 0 : ctx.li.filter((li => li[0] === attrName));\\n            if (qrls && qrls.length > 0) {\\n                for (const q of qrls) {\\n                    await q[1].getFn([ element, ev ], (() => element.isConnected))(ev, element);\\n                }\\n                return;\\n            }\\n            const attrValue = getAttribute(element, attrName);\\n            if (attrValue) {\\n                const container = element.closest(\"[q\\\\\\\\:container]\");\\n                const base = new URL(getAttribute(container, \"q:base\"), doc.baseURI);\\n                for (const qrl of attrValue.split(\"\\\\n\")) {\\n                    const url = new URL(qrl, base);\\n                    const symbolName = url.hash.replace(/^#?([^?[|]*).*$/, \"$1\") || \"default\";\\n                    const reqTime = performance.now();\\n                    const module = import(\\n                    /* @vite-ignore */\\n                    url.href.split(\"#\")[0]);\\n                    resolveContainer(container);\\n                    const handler = (await module)[symbolName];\\n                    const previousCtx = doc.__q_context__;\\n                    if (element.isConnected) {\\n                        try {\\n                            doc.__q_context__ = [ element, ev, url ];\\n                            emitEvent(\"qsymbol\", {\\n                                symbol: symbolName,\\n                                element: element,\\n                                reqTime: reqTime\\n                            });\\n                            await handler(ev, element);\\n                        } finally {\\n                            doc.__q_context__ = previousCtx;\\n                        }\\n                    }\\n                }\\n            }\\n        };\\n        const emitEvent = (eventName, detail) => {\\n            doc.dispatchEvent(createEvent(eventName, detail));\\n        };\\n        const camelToKebab = str => str.replace(/([A-Z])/g, (a => \"-\" + a.toLowerCase()));\\n        const processDocumentEvent = async ev => {\\n            let type = camelToKebab(ev.type);\\n            let element = ev.target;\\n            broadcast(\"-document\", ev, type);\\n            while (element && element.getAttribute) {\\n                await dispatch(element, \"\", ev, type);\\n                element = ev.bubbles && !0 !== ev.cancelBubble ? element.parentElement : null;\\n            }\\n        };\\n        const processWindowEvent = ev => {\\n            broadcast(\"-window\", ev, camelToKebab(ev.type));\\n        };\\n        const processReadyStateChange = () => {\\n            var _a;\\n            const readyState = doc.readyState;\\n            if (!hasInitialized && (\"interactive\" == readyState || \"complete\" == readyState)) {\\n                hasInitialized = 1;\\n                emitEvent(\"qinit\");\\n                (null != (_a = win.requestIdleCallback) ? _a : win.setTimeout).bind(win)((() => emitEvent(\"qidle\")));\\n                if (events.has(\"qvisible\")) {\\n                    const results = querySelectorAll(\"[on\\\\\\\\:qvisible]\");\\n                    const observer = new IntersectionObserver((entries => {\\n                        for (const entry of entries) {\\n                            if (entry.isIntersecting) {\\n                                observer.unobserve(entry.target);\\n                                dispatch(entry.target, \"\", createEvent(\"qvisible\", entry));\\n                            }\\n                        }\\n                    }));\\n                    results.forEach((el => observer.observe(el)));\\n                }\\n            }\\n        };\\n        const addEventListener = (el, eventName, handler, capture = !1) => el.addEventListener(eventName, handler, {\\n            capture: capture,\\n            passive: !1\\n        });\\n        const push = eventNames => {\\n            for (const eventName of eventNames) {\\n                if (!events.has(eventName)) {\\n                    addEventListener(doc, eventName, processDocumentEvent, !0);\\n                    addEventListener(win, eventName, processWindowEvent);\\n                    events.add(eventName);\\n                }\\n            }\\n        };\\n        if (!doc.qR) {\\n            const qwikevents = win.qwikevents;\\n            Array.isArray(qwikevents) && push(qwikevents);\\n            win.qwikevents = {\\n                push: (...e) => push(e)\\n            };\\n            addEventListener(doc, \"readystatechange\", processReadyStateChange);\\n            processReadyStateChange();\\n        }\\n    })(document);\\n})();';\nfunction getQwikLoaderScript(opts = {}) {\n  if (Array.isArray(opts.events) && opts.events.length > 0) {\n    const loader = opts.debug ? QWIK_LOADER_OPTIMIZE_DEBUG : QWIK_LOADER_OPTIMIZE_MINIFIED;\n    return loader.replace(\"window.qEvents\", JSON.stringify(opts.events));\n  }\n  return opts.debug ? QWIK_LOADER_DEFAULT_DEBUG : QWIK_LOADER_DEFAULT_MINIFIED;\n}\n\n// packages/qwik/src/server/prefetch-strategy.ts\nfunction getPrefetchResources(snapshotResult, opts, resolvedManifest) {\n  if (!resolvedManifest) {\n    return [];\n  }\n  const prefetchStrategy = opts.prefetchStrategy;\n  const buildBase = getBuildBase(opts);\n  if (prefetchStrategy !== null) {\n    if (!prefetchStrategy || !prefetchStrategy.symbolsToPrefetch || prefetchStrategy.symbolsToPrefetch === \"auto\") {\n      return getAutoPrefetch(snapshotResult, resolvedManifest, buildBase);\n    }\n    if (typeof prefetchStrategy.symbolsToPrefetch === \"function\") {\n      try {\n        return prefetchStrategy.symbolsToPrefetch({ manifest: resolvedManifest.manifest });\n      } catch (e) {\n        console.error(\"getPrefetchUrls, symbolsToPrefetch()\", e);\n      }\n    }\n  }\n  return [];\n}\nfunction getAutoPrefetch(snapshotResult, resolvedManifest, buildBase) {\n  const prefetchResources = [];\n  const qrls = snapshotResult?.qrls;\n  const { mapper, manifest } = resolvedManifest;\n  const urls = /* @__PURE__ */ new Map();\n  if (Array.isArray(qrls)) {\n    for (const obj of qrls) {\n      const qrlSymbolName = obj.getHash();\n      const resolvedSymbol = mapper[qrlSymbolName];\n      if (resolvedSymbol) {\n        addBundle(manifest, urls, prefetchResources, buildBase, resolvedSymbol[1]);\n      }\n    }\n  }\n  return prefetchResources;\n}\nfunction addBundle(manifest, urls, prefetchResources, buildBase, bundleFileName) {\n  const url = buildBase + bundleFileName;\n  let prefetchResource = urls.get(url);\n  if (!prefetchResource) {\n    prefetchResource = {\n      url,\n      imports: []\n    };\n    urls.set(url, prefetchResource);\n    const bundle = manifest.bundles[bundleFileName];\n    if (bundle) {\n      if (Array.isArray(bundle.imports)) {\n        for (const importedFilename of bundle.imports) {\n          addBundle(manifest, urls, prefetchResource.imports, buildBase, importedFilename);\n        }\n      }\n    }\n  }\n  prefetchResources.push(prefetchResource);\n}\n\n// packages/qwik/src/optimizer/src/manifest.ts\nfunction getValidManifest(manifest) {\n  if (manifest != null && manifest.mapping != null && typeof manifest.mapping === \"object\" && manifest.symbols != null && typeof manifest.symbols === \"object\" && manifest.bundles != null && typeof manifest.bundles === \"object\") {\n    return manifest;\n  }\n  return void 0;\n}\n\n// packages/qwik/src/server/prefetch-implementation.ts\nimport { Fragment, jsx } from \"@builder.io/qwik\";\n\n// packages/qwik/src/server/prefetch-utils.ts\nfunction workerFetchScript() {\n  const fetch = `Promise.all(e.data.map(u=>fetch(u))).finally(()=>{setTimeout(postMessage({}),9999)})`;\n  const workerBody = `onmessage=(e)=>{${fetch}}`;\n  const blob = `new Blob(['${workerBody}'],{type:\"text/javascript\"})`;\n  const url = `URL.createObjectURL(${blob})`;\n  let s = `const w=new Worker(${url});`;\n  s += `w.postMessage(u.map(u=>new URL(u,origin)+''));`;\n  s += `w.onmessage=()=>{w.terminate()};`;\n  return s;\n}\nfunction prefetchUrlsEventScript(prefetchResources) {\n  const data = {\n    bundles: flattenPrefetchResources(prefetchResources).map((u) => u.split(\"/\").pop())\n  };\n  return `document.dispatchEvent(new CustomEvent(\"qprefetch\",{detail:${JSON.stringify(data)}}))`;\n}\nfunction flattenPrefetchResources(prefetchResources) {\n  const urls = [];\n  const addPrefetchResource = (prefetchResources2) => {\n    if (Array.isArray(prefetchResources2)) {\n      for (const prefetchResource of prefetchResources2) {\n        if (!urls.includes(prefetchResource.url)) {\n          urls.push(prefetchResource.url);\n          addPrefetchResource(prefetchResource.imports);\n        }\n      }\n    }\n  };\n  addPrefetchResource(prefetchResources);\n  return urls;\n}\nfunction getMostReferenced(prefetchResources) {\n  const common = /* @__PURE__ */ new Map();\n  let total = 0;\n  const addPrefetchResource = (prefetchResources2, visited2) => {\n    if (Array.isArray(prefetchResources2)) {\n      for (const prefetchResource of prefetchResources2) {\n        const count = common.get(prefetchResource.url) || 0;\n        common.set(prefetchResource.url, count + 1);\n        total++;\n        if (!visited2.has(prefetchResource.url)) {\n          visited2.add(prefetchResource.url);\n          addPrefetchResource(prefetchResource.imports, visited2);\n        }\n      }\n    }\n  };\n  const visited = /* @__PURE__ */ new Set();\n  for (const resource of prefetchResources) {\n    visited.clear();\n    addPrefetchResource(resource.imports, visited);\n  }\n  const threshold = total / common.size * 2;\n  const urls = Array.from(common.entries());\n  urls.sort((a, b) => b[1] - a[1]);\n  return urls.slice(0, 5).filter((e) => e[1] > threshold).map((e) => e[0]);\n}\n\n// packages/qwik/src/server/prefetch-implementation.ts\nfunction applyPrefetchImplementation(prefetchStrategy, prefetchResources, nonce) {\n  const prefetchImpl = normalizePrefetchImplementation(prefetchStrategy?.implementation);\n  const prefetchNodes = [];\n  if (prefetchImpl.prefetchEvent === \"always\") {\n    prefetchUrlsEvent(prefetchNodes, prefetchResources, nonce);\n  }\n  if (prefetchImpl.linkInsert === \"html-append\") {\n    linkHtmlImplementation(prefetchNodes, prefetchResources, prefetchImpl);\n  }\n  if (prefetchImpl.linkInsert === \"js-append\") {\n    linkJsImplementation(prefetchNodes, prefetchResources, prefetchImpl, nonce);\n  } else if (prefetchImpl.workerFetchInsert === \"always\") {\n    workerFetchImplementation(prefetchNodes, prefetchResources, nonce);\n  }\n  if (prefetchNodes.length > 0) {\n    return jsx(Fragment, { children: prefetchNodes });\n  }\n  return null;\n}\nfunction prefetchUrlsEvent(prefetchNodes, prefetchResources, nonce) {\n  const mostReferenced = getMostReferenced(prefetchResources);\n  for (const url of mostReferenced) {\n    prefetchNodes.push(\n      jsx(\"link\", {\n        rel: \"modulepreload\",\n        href: url,\n        nonce\n      })\n    );\n  }\n  prefetchNodes.push(\n    jsx(\"script\", {\n      dangerouslySetInnerHTML: prefetchUrlsEventScript(prefetchResources),\n      nonce\n    })\n  );\n}\nfunction linkHtmlImplementation(prefetchNodes, prefetchResources, prefetchImpl) {\n  const urls = flattenPrefetchResources(prefetchResources);\n  const rel = prefetchImpl.linkRel || \"prefetch\";\n  for (const url of urls) {\n    const attributes = {};\n    attributes[\"href\"] = url;\n    attributes[\"rel\"] = rel;\n    if (rel === \"prefetch\" || rel === \"preload\") {\n      if (url.endsWith(\".js\")) {\n        attributes[\"as\"] = \"script\";\n      }\n    }\n    prefetchNodes.push(jsx(\"link\", attributes, void 0));\n  }\n}\nfunction linkJsImplementation(prefetchNodes, prefetchResources, prefetchImpl, nonce) {\n  const rel = prefetchImpl.linkRel || \"prefetch\";\n  let s = ``;\n  if (prefetchImpl.workerFetchInsert === \"no-link-support\") {\n    s += `let supportsLinkRel = true;`;\n  }\n  s += `const u=${JSON.stringify(flattenPrefetchResources(prefetchResources))};`;\n  s += `u.map((u,i)=>{`;\n  s += `const l=document.createElement('link');`;\n  s += `l.setAttribute(\"href\",u);`;\n  s += `l.setAttribute(\"rel\",\"${rel}\");`;\n  if (prefetchImpl.workerFetchInsert === \"no-link-support\") {\n    s += `if(i===0){`;\n    s += `try{`;\n    s += `supportsLinkRel=l.relList.supports(\"${rel}\");`;\n    s += `}catch(e){}`;\n    s += `}`;\n  }\n  s += `document.body.appendChild(l);`;\n  s += `});`;\n  if (prefetchImpl.workerFetchInsert === \"no-link-support\") {\n    s += `if(!supportsLinkRel){`;\n    s += workerFetchScript();\n    s += `}`;\n  }\n  if (prefetchImpl.workerFetchInsert === \"always\") {\n    s += workerFetchScript();\n  }\n  prefetchNodes.push(\n    jsx(\"script\", {\n      type: \"module\",\n      dangerouslySetInnerHTML: s,\n      nonce\n    })\n  );\n}\nfunction workerFetchImplementation(prefetchNodes, prefetchResources, nonce) {\n  let s = `const u=${JSON.stringify(flattenPrefetchResources(prefetchResources))};`;\n  s += workerFetchScript();\n  prefetchNodes.push(\n    jsx(\"script\", {\n      type: \"module\",\n      dangerouslySetInnerHTML: s,\n      nonce\n    })\n  );\n}\nfunction normalizePrefetchImplementation(input) {\n  if (input && typeof input === \"object\") {\n    return input;\n  }\n  return PrefetchImplementationDefault;\n}\nvar PrefetchImplementationDefault = {\n  linkInsert: null,\n  linkRel: null,\n  workerFetchInsert: null,\n  prefetchEvent: \"always\"\n};\n\n// packages/qwik/src/server/render.ts\nvar DOCTYPE = \"<!DOCTYPE html>\";\nasync function renderToStream(rootNode, opts) {\n  let stream = opts.stream;\n  let bufferSize = 0;\n  let totalSize = 0;\n  let networkFlushes = 0;\n  let firstFlushTime = 0;\n  let buffer = \"\";\n  let snapshotResult;\n  const inOrderStreaming = opts.streaming?.inOrder ?? {\n    strategy: \"auto\",\n    maximunInitialChunk: 5e4,\n    maximunChunk: 3e4\n  };\n  const containerTagName = opts.containerTagName ?? \"html\";\n  const containerAttributes = opts.containerAttributes ?? {};\n  const nativeStream = stream;\n  const firstFlushTimer = createTimer();\n  const buildBase = getBuildBase(opts);\n  const resolvedManifest = resolveManifest(opts.manifest);\n  function flush() {\n    if (buffer) {\n      nativeStream.write(buffer);\n      buffer = \"\";\n      bufferSize = 0;\n      networkFlushes++;\n      if (networkFlushes === 1) {\n        firstFlushTime = firstFlushTimer();\n      }\n    }\n  }\n  function enqueue(chunk) {\n    const len = chunk.length;\n    bufferSize += len;\n    totalSize += len;\n    buffer += chunk;\n  }\n  switch (inOrderStreaming.strategy) {\n    case \"disabled\":\n      stream = {\n        write: enqueue\n      };\n      break;\n    case \"direct\":\n      stream = nativeStream;\n      break;\n    case \"auto\":\n      let count = 0;\n      let forceFlush = false;\n      const minimunChunkSize = inOrderStreaming.maximunChunk ?? 0;\n      const initialChunkSize = inOrderStreaming.maximunInitialChunk ?? 0;\n      stream = {\n        write(chunk) {\n          if (chunk === \"<!--qkssr-f-->\") {\n            forceFlush || (forceFlush = true);\n          } else if (chunk === \"<!--qkssr-pu-->\") {\n            count++;\n          } else if (chunk === \"<!--qkssr-po-->\") {\n            count--;\n          } else {\n            enqueue(chunk);\n          }\n          const chunkSize = networkFlushes === 0 ? initialChunkSize : minimunChunkSize;\n          if (count === 0 && (forceFlush || bufferSize >= chunkSize)) {\n            forceFlush = false;\n            flush();\n          }\n        }\n      };\n      break;\n  }\n  if (containerTagName === \"html\") {\n    stream.write(DOCTYPE);\n  } else {\n    stream.write(\"<!--cq-->\");\n    if (opts.qwikLoader) {\n      if (opts.qwikLoader.include === void 0) {\n        opts.qwikLoader.include = \"never\";\n      }\n      if (opts.qwikLoader.position === void 0) {\n        opts.qwikLoader.position = \"bottom\";\n      }\n    } else {\n      opts.qwikLoader = {\n        include: \"never\"\n      };\n    }\n  }\n  if (!opts.manifest) {\n    console.warn(\n      `Missing client manifest, loading symbols in the client might 404. Please ensure the client build has run and generated the manifest for the server build.`\n    );\n  }\n  await setServerPlatform(opts, resolvedManifest);\n  const injections = resolvedManifest?.manifest.injections;\n  const beforeContent = injections ? injections.map((injection) => jsx2(injection.tag, injection.attributes ?? {})) : void 0;\n  const renderTimer = createTimer();\n  const renderSymbols = [];\n  let renderTime = 0;\n  let snapshotTime = 0;\n  await _renderSSR(rootNode, {\n    stream,\n    containerTagName,\n    containerAttributes,\n    serverData: opts.serverData,\n    base: buildBase,\n    beforeContent,\n    beforeClose: async (contexts, containerState, _dynamic, textNodes) => {\n      renderTime = renderTimer();\n      const snapshotTimer = createTimer();\n      snapshotResult = await _pauseFromContexts(contexts, containerState, void 0, textNodes);\n      const children = [];\n      if (opts.prefetchStrategy !== null) {\n        const prefetchResources = getPrefetchResources(snapshotResult, opts, resolvedManifest);\n        if (prefetchResources.length > 0) {\n          const prefetchImpl = applyPrefetchImplementation(\n            opts.prefetchStrategy,\n            prefetchResources,\n            opts.serverData?.nonce\n          );\n          if (prefetchImpl) {\n            children.push(prefetchImpl);\n          }\n        }\n      }\n      const jsonData = JSON.stringify(snapshotResult.state, void 0, isDev ? \"  \" : void 0);\n      children.push(\n        jsx2(\"script\", {\n          type: \"qwik/json\",\n          dangerouslySetInnerHTML: escapeText(jsonData),\n          nonce: opts.serverData?.nonce\n        })\n      );\n      if (snapshotResult.funcs.length > 0) {\n        children.push(\n          jsx2(\"script\", {\n            \"q:func\": \"qwik/json\",\n            dangerouslySetInnerHTML: serializeFunctions(snapshotResult.funcs),\n            nonce: opts.serverData?.nonce\n          })\n        );\n      }\n      const needLoader = !snapshotResult || snapshotResult.mode !== \"static\";\n      const includeMode = opts.qwikLoader?.include ?? \"auto\";\n      const includeLoader = includeMode === \"always\" || includeMode === \"auto\" && needLoader;\n      if (includeLoader) {\n        const qwikLoaderScript = getQwikLoaderScript({\n          events: opts.qwikLoader?.events,\n          debug: opts.debug\n        });\n        children.push(\n          jsx2(\"script\", {\n            id: \"qwikloader\",\n            dangerouslySetInnerHTML: qwikLoaderScript,\n            nonce: opts.serverData?.nonce\n          })\n        );\n      }\n      const extraListeners = Array.from(containerState.$events$, (s) => JSON.stringify(s));\n      if (extraListeners.length > 0) {\n        let content = `window.qwikevents.push(${extraListeners.join(\", \")})`;\n        if (!includeLoader) {\n          content = `window.qwikevents||=[];${content}`;\n        }\n        children.push(\n          jsx2(\"script\", {\n            dangerouslySetInnerHTML: content,\n            nonce: opts.serverData?.nonce\n          })\n        );\n      }\n      collectRenderSymbols(renderSymbols, contexts);\n      snapshotTime = snapshotTimer();\n      return jsx2(Fragment2, { children });\n    },\n    manifestHash: resolvedManifest?.manifest.manifestHash || \"dev\"\n  });\n  if (containerTagName !== \"html\") {\n    stream.write(\"<!--/cq-->\");\n  }\n  flush();\n  const isDynamic = snapshotResult.resources.some((r) => r._cache !== Infinity);\n  const result = {\n    prefetchResources: void 0,\n    snapshotResult,\n    flushes: networkFlushes,\n    manifest: resolvedManifest?.manifest,\n    size: totalSize,\n    isStatic: !isDynamic,\n    timing: {\n      render: renderTime,\n      snapshot: snapshotTime,\n      firstFlush: firstFlushTime\n    },\n    _symbols: renderSymbols\n  };\n  return result;\n}\nasync function renderToString(rootNode, opts = {}) {\n  const chunks = [];\n  const stream = {\n    write(chunk) {\n      chunks.push(chunk);\n    }\n  };\n  const result = await renderToStream(rootNode, {\n    base: opts.base,\n    containerAttributes: opts.containerAttributes,\n    containerTagName: opts.containerTagName,\n    locale: opts.locale,\n    manifest: opts.manifest,\n    symbolMapper: opts.symbolMapper,\n    qwikLoader: opts.qwikLoader,\n    serverData: opts.serverData,\n    prefetchStrategy: opts.prefetchStrategy,\n    stream\n  });\n  return {\n    isStatic: result.isStatic,\n    prefetchResources: result.prefetchResources,\n    timing: result.timing,\n    manifest: result.manifest,\n    snapshotResult: result.snapshotResult,\n    html: chunks.join(\"\")\n  };\n}\nfunction resolveManifest(manifest) {\n  if (!manifest) {\n    return void 0;\n  }\n  if (\"mapper\" in manifest) {\n    return manifest;\n  }\n  manifest = getValidManifest(manifest);\n  if (manifest) {\n    const mapper = {};\n    Object.entries(manifest.mapping).forEach(([key, value]) => {\n      mapper[getSymbolHash(key)] = [key, value];\n    });\n    return {\n      mapper,\n      manifest\n    };\n  }\n  return void 0;\n}\nvar escapeText = (str) => {\n  return str.replace(/<(\\/?script)/g, \"\\\\x3C$1\");\n};\nfunction collectRenderSymbols(renderSymbols, elements) {\n  for (const ctx of elements) {\n    const symbol = ctx.$componentQrl$?.getSymbol();\n    if (symbol && !renderSymbols.includes(symbol)) {\n      renderSymbols.push(symbol);\n    }\n  }\n}\nfunction serializeFunctions(funcs) {\n  return `document.currentScript.qFuncs=[${funcs.join(\",\\n\")}]`;\n}\n\n// packages/qwik/src/server/index.ts\nasync function setServerPlatform2(manifest) {\n  const platform = createPlatform({ manifest }, resolveManifest(manifest));\n  setPlatform2(platform);\n}\nexport {\n  getQwikLoaderScript,\n  renderToStream,\n  renderToString,\n  resolveManifest,\n  setServerPlatform2 as setServerPlatform,\n  versions\n};\n",
      "start": 1696585308869,
      "end": 1696585309051,
      "sourcemaps": null
    },
    {
      "name": "astro:build",
      "start": 1696585309051,
      "end": 1696585309051,
      "order": "pre"
    },
    {
      "name": "astro:vite-plugin-env",
      "start": 1696585309051,
      "end": 1696585309051,
      "order": "pre"
    },
    {
      "name": "astro:jsx",
      "start": 1696585309051,
      "end": 1696585309051,
      "order": "pre"
    },
    {
      "name": "astro:content-asset-propagation",
      "start": 1696585309051,
      "end": 1696585309051,
      "order": "pre"
    },
    {
      "name": "vite-plugin-qwik",
      "start": 1696585309051,
      "end": 1696585309051,
      "order": "pre"
    },
    {
      "name": "vite-plugin-qwik",
      "start": 1696585309051,
      "end": 1696585309051,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1696585309051,
      "end": 1696585309051,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1696585309051,
      "end": 1696585309051,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1696585309051,
      "end": 1696585309051,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1696585309051,
      "end": 1696585309051,
      "order": "normal"
    },
    {
      "name": "astro:html",
      "start": 1696585309051,
      "end": 1696585309051,
      "order": "normal"
    },
    {
      "name": "astro:postprocess",
      "start": 1696585309051,
      "end": 1696585309051,
      "order": "normal"
    },
    {
      "name": "astro:head-metadata",
      "start": 1696585309051,
      "end": 1696585309051,
      "order": "normal"
    },
    {
      "name": "astro:content-imports",
      "start": 1696585309051,
      "end": 1696585309051,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1696585309051,
      "end": 1696585309051,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1696585309051,
      "end": 1696585309051,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1696585309051,
      "end": 1696585309051,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1696585309051,
      "end": 1696585309051,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1696585309051,
      "end": 1696585309051,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1696585309052,
      "end": 1696585309052,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1696585309052,
      "end": 1696585309052,
      "order": "normal"
    },
    {
      "name": "astro:scripts:page-ssr",
      "start": 1696585309052,
      "end": 1696585309052,
      "order": "post"
    },
    {
      "name": "astro:scanner",
      "start": 1696585309052,
      "end": 1696585309052,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1696585309052,
      "end": 1696585309052,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1696585309052,
      "end": 1696585309052,
      "order": "normal"
    }
  ]
}
