{
  "resolvedId": "/home/jackshelton/dev/open-source/astro-qwik/node_modules/.pnpm/@builder.io+qwik@1.2.11_undici@5.24.0/node_modules/@builder.io/qwik/core.prod.mjs",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/**\n * @license\n * @builder.io/qwik 1.2.11\n * Copyright Builder.io, Inc. All Rights Reserved.\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/BuilderIO/qwik/blob/main/LICENSE\n */\nimport { isServer, isBrowser } from \"@builder.io/qwik/build\";\n\nconst implicit$FirstArg = fn => function(first, ...rest) {\n    return fn.call(null, $(first), ...rest);\n};\n\nconst qDev = !1;\n\nconst qInspector = !1;\n\nconst qSerialize = !0;\n\nconst qDynamicPlatform = !0;\n\nconst qTest = !1;\n\nconst qRuntimeQrl = !1;\n\nconst seal = () => {\n    qDev;\n};\n\nconst isNode$1 = value => value && \"number\" == typeof value.nodeType;\n\nconst isDocument = value => 9 === value.nodeType;\n\nconst isElement$1 = value => 1 === value.nodeType;\n\nconst isQwikElement = value => {\n    const nodeType = value.nodeType;\n    return 1 === nodeType || 111 === nodeType;\n};\n\nconst isNodeElement = value => {\n    const nodeType = value.nodeType;\n    return 1 === nodeType || 111 === nodeType || 3 === nodeType;\n};\n\nconst isVirtualElement = value => 111 === value.nodeType;\n\nconst isText = value => 3 === value.nodeType;\n\nconst isComment = value => 8 === value.nodeType;\n\nconst STYLE = \"\";\n\nconst logError = (message, ...optionalParams) => createAndLogError(!0, message, ...optionalParams);\n\nconst throwErrorAndStop = (message, ...optionalParams) => {\n    throw createAndLogError(!1, message, ...optionalParams);\n};\n\nconst logErrorAndStop = (message, ...optionalParams) => createAndLogError(!0, message, ...optionalParams);\n\nconst _printed = /*#__PURE__*/ new Set;\n\nconst logOnceWarn = () => {\n    qDev;\n};\n\nconst logWarn = () => {\n    qDev;\n};\n\nconst logDebug = () => {\n    qDev;\n};\n\nconst tryGetContext$1 = element => element._qc_;\n\nconst printParams = optionalParams => optionalParams;\n\nconst printElement = el => {\n    const ctx = el._qc_;\n    const isServer = /*#__PURE__*/ (() => \"undefined\" != typeof process && !!process.versions && !!process.versions.node)();\n    return {\n        tagName: el.tagName,\n        renderQRL: ctx?.$componentQrl$?.getSymbol(),\n        element: isServer ? void 0 : el,\n        ctx: isServer ? void 0 : ctx\n    };\n};\n\nconst createAndLogError = (asyncThrow, message, ...optionalParams) => {\n    const err = message instanceof Error ? message : new Error(message);\n    return console.error(\"%cQWIK ERROR\", \"\", err.stack || err.message, ...printParams(optionalParams)), \n    asyncThrow && setTimeout((() => {\n        throw err;\n    }), 0), err;\n};\n\nconst QError_stringifyClassOrStyle = 0;\n\nconst QError_verifySerializable = 3;\n\nconst QError_cannotRenderOverExistingContainer = 5;\n\nconst QError_setProperty = 6;\n\nconst QError_qrlIsNotFunction = 10;\n\nconst QError_dynamicImportFailed = 11;\n\nconst QError_unknownTypeArgument = 12;\n\nconst QError_notFoundContext = 13;\n\nconst QError_useMethodOutsideContext = 14;\n\nconst QError_immutableProps = 17;\n\nconst QError_useInvokeContext = 20;\n\nconst QError_containerAlreadyPaused = 21;\n\nconst QError_invalidJsxNodeType = 25;\n\nconst QError_trackUseStore = 26;\n\nconst QError_missingObjectId = 27;\n\nconst QError_invalidContext = 28;\n\nconst QError_canNotRenderHTML = 29;\n\nconst QError_qrlMissingContainer = 30;\n\nconst QError_qrlMissingChunk = 31;\n\nconst QError_invalidRefValue = 32;\n\nconst qError = (code, ...parts) => {\n    const text = codeToText(code);\n    return logErrorAndStop(text, ...parts);\n};\n\nconst codeToText = code => `Code(${code})`;\n\nconst createPlatform = () => ({\n    isServer,\n    importSymbol(containerEl, url, symbolName) {\n        if (isServer) {\n            const hash = getSymbolHash(symbolName);\n            const regSym = globalThis.__qwik_reg_symbols?.get(hash);\n            if (regSym) {\n                return regSym;\n            }\n        }\n        if (!url) {\n            throw qError(31, symbolName);\n        }\n        if (!containerEl) {\n            throw qError(30, url, symbolName);\n        }\n        const urlDoc = toUrl(containerEl.ownerDocument, containerEl, url).toString();\n        const urlCopy = new URL(urlDoc);\n        urlCopy.hash = \"\", urlCopy.search = \"\";\n        return import(urlCopy.href).then((mod => mod[symbolName]));\n    },\n    raf: fn => new Promise((resolve => {\n        requestAnimationFrame((() => {\n            resolve(fn());\n        }));\n    })),\n    nextTick: fn => new Promise((resolve => {\n        setTimeout((() => {\n            resolve(fn());\n        }));\n    })),\n    chunkForSymbol: (symbolName, chunk) => [ symbolName, chunk ?? \"_\" ]\n});\n\nconst toUrl = (doc, containerEl, url) => {\n    const baseURI = doc.baseURI;\n    const base = new URL(containerEl.getAttribute(\"q:base\") ?? baseURI, baseURI);\n    return new URL(url, base);\n};\n\nlet _platform = /*#__PURE__ */ createPlatform();\n\nconst setPlatform = plt => _platform = plt;\n\nconst getPlatform = () => _platform;\n\nconst isServerPlatform = () => _platform.isServer;\n\nconst ASSERT_DISCLAIMER = \"Internal assert, this is likely caused by a bug in Qwik: \";\n\nfunction assertDefined() {\n    qDev;\n}\n\nfunction assertEqual() {\n    qDev;\n}\n\nfunction assertFail() {\n    qDev;\n}\n\nfunction assertTrue() {\n    qDev;\n}\n\nfunction assertNumber() {\n    qDev;\n}\n\nfunction assertString() {\n    qDev;\n}\n\nfunction assertQwikElement() {\n    qDev;\n}\n\nfunction assertElement() {\n    qDev;\n}\n\nconst isSerializableObject = v => {\n    const proto = Object.getPrototypeOf(v);\n    return proto === Object.prototype || null === proto;\n};\n\nconst isObject = v => v && \"object\" == typeof v;\n\nconst isArray = v => Array.isArray(v);\n\nconst isString = v => \"string\" == typeof v;\n\nconst isFunction = v => \"function\" == typeof v;\n\nconst isPromise = value => value && \"function\" == typeof value.then;\n\nconst safeCall = (call, thenFn, rejectFn) => {\n    try {\n        const promise = call();\n        return isPromise(promise) ? promise.then(thenFn, rejectFn) : thenFn(promise);\n    } catch (e) {\n        return rejectFn(e);\n    }\n};\n\nconst then = (promise, thenFn) => isPromise(promise) ? promise.then(thenFn) : thenFn(promise);\n\nconst promiseAll = promises => promises.some(isPromise) ? Promise.all(promises) : promises;\n\nconst promiseAllLazy = promises => promises.length > 0 ? Promise.all(promises) : promises;\n\nconst isNotNullable = v => null != v;\n\nconst delay = timeout => new Promise((resolve => {\n    setTimeout(resolve, timeout);\n}));\n\nconst EMPTY_ARRAY = [];\n\nconst EMPTY_OBJ = {};\n\nconst getDocument = node => {\n    if (\"undefined\" != typeof document) {\n        return document;\n    }\n    if (9 === node.nodeType) {\n        return node;\n    }\n    const doc = node.ownerDocument;\n    return assertDefined(doc, \"doc must be defined\"), doc;\n};\n\nconst OnRenderProp = \"q:renderFn\";\n\nconst ComponentStylesPrefixContent = \"⭐️\";\n\nconst QSlot = \"q:slot\";\n\nconst QSlotRef = \"q:sref\";\n\nconst QSlotS = \"q:s\";\n\nconst QStyle = \"q:style\";\n\nconst QScopedStyle = \"q:sstyle\";\n\nconst QLocaleAttr = \"q:locale\";\n\nconst QContainerAttr = \"q:container\";\n\nconst QContainerSelector = \"[q\\\\:container]\";\n\nconst ResourceEvent = \"qResource\";\n\nconst ComputedEvent = \"qComputed\";\n\nconst RenderEvent = \"qRender\";\n\nconst ELEMENT_ID = \"q:id\";\n\nconst ELEMENT_ID_PREFIX = \"#\";\n\nconst fromCamelToKebabCase = text => text.replace(/([A-Z])/g, \"-$1\").toLowerCase();\n\nconst fromKebabToCamelCase = text => text.replace(/-./g, (x => x[1].toUpperCase()));\n\nconst directSetAttribute = (el, prop, value) => el.setAttribute(prop, value);\n\nconst directGetAttribute = (el, prop) => el.getAttribute(prop);\n\nconst directRemoveAttribute = (el, prop) => el.removeAttribute(prop);\n\nconst CONTAINER_STATE = Symbol(\"ContainerState\");\n\nconst _getContainerState = containerEl => {\n    let set = containerEl[CONTAINER_STATE];\n    \n    return set || (containerEl[CONTAINER_STATE] = set = createContainerState(containerEl, directGetAttribute(containerEl, \"q:base\") ?? \"/\")), \n    set;\n};\n\nconst createContainerState = (containerEl, base) => {\n    const containerState = {\n        $containerEl$: containerEl,\n        $elementIndex$: 0,\n        $styleMoved$: !1,\n        $proxyMap$: new WeakMap,\n        $opsNext$: new Set,\n        $taskNext$: new Set,\n        $taskStaging$: new Set,\n        $hostsNext$: new Set,\n        $hostsStaging$: new Set,\n        $styleIds$: new Set,\n        $events$: new Set,\n        $serverData$: {},\n        $base$: base,\n        $renderPromise$: void 0,\n        $hostsRendering$: void 0,\n        $pauseCtx$: void 0,\n        $subsManager$: null\n    };\n    return seal(), containerState.$subsManager$ = createSubscriptionManager(containerState), \n    containerState;\n};\n\nconst removeContainerState = containerEl => {\n    delete containerEl[CONTAINER_STATE];\n};\n\nconst setRef = (value, elm) => {\n    if (isFunction(value)) {\n        return value(elm);\n    }\n    if (isObject(value) && \"value\" in value) {\n        return value.value = elm;\n    }\n    throw qError(32, value);\n};\n\nconst SHOW_ELEMENT = 1;\n\nconst SHOW_COMMENT$1 = 128;\n\nconst FILTER_REJECT$1 = 2;\n\nconst FILTER_SKIP = 3;\n\nconst isContainer$1 = el => isElement$1(el) && el.hasAttribute(\"q:container\");\n\nconst intToStr = nu => nu.toString(36);\n\nconst strToInt = nu => parseInt(nu, 36);\n\nconst getEventName = attribute => {\n    const colonPos = attribute.indexOf(\":\");\n    return attribute ? attribute.slice(colonPos + 1).replace(/-./g, (x => x[1].toUpperCase())) : attribute;\n};\n\nconst ON_PROP_REGEX = /^(on|window:|document:)/;\n\nconst PREVENT_DEFAULT = \"preventdefault:\";\n\nconst isOnProp = prop => prop.endsWith(\"$\") && ON_PROP_REGEX.test(prop);\n\nconst groupListeners = listeners => {\n    if (0 === listeners.length) {\n        return EMPTY_ARRAY;\n    }\n    if (1 === listeners.length) {\n        const listener = listeners[0];\n        return [ [ listener[0], [ listener[1] ] ] ];\n    }\n    const keys = [];\n    for (let i = 0; i < listeners.length; i++) {\n        const eventName = listeners[i][0];\n        keys.includes(eventName) || keys.push(eventName);\n    }\n    return keys.map((eventName => [ eventName, listeners.filter((l => l[0] === eventName)).map((a => a[1])) ]));\n};\n\nconst setEvent = (existingListeners, prop, input, containerEl) => {\n    if (assertTrue(prop.endsWith(\"$\"), \"render: event property does not end with $\", prop), \n    prop = normalizeOnProp(prop.slice(0, -1)), input) {\n        if (isArray(input)) {\n            const processed = input.flat(1 / 0).filter((q => null != q)).map((q => [ prop, ensureQrl(q, containerEl) ]));\n            existingListeners.push(...processed);\n        } else {\n            existingListeners.push([ prop, ensureQrl(input, containerEl) ]);\n        }\n    }\n    return prop;\n};\n\nconst PREFIXES = [ \"on\", \"window:on\", \"document:on\" ];\n\nconst SCOPED = [ \"on\", \"on-window\", \"on-document\" ];\n\nconst normalizeOnProp = prop => {\n    let scope = \"on\";\n    for (let i = 0; i < PREFIXES.length; i++) {\n        const prefix = PREFIXES[i];\n        if (prop.startsWith(prefix)) {\n            scope = SCOPED[i], prop = prop.slice(prefix.length);\n            break;\n        }\n    }\n    return scope + \":\" + (prop = prop.startsWith(\"-\") ? fromCamelToKebabCase(prop.slice(1)) : prop.toLowerCase());\n};\n\nconst ensureQrl = (value, containerEl) => \n{\n    console.log(value);\n    console.log(containerEl);\n    assertQrl(value), value.$setContainer$(containerEl), value\n};\n\nconst getDomListeners = (elCtx, containerEl) => {\n    const attributes = elCtx.$element$.attributes;\n    const listeners = [];\n    for (let i = 0; i < attributes.length; i++) {\n        const {name, value} = attributes.item(i);\n        if (name.startsWith(\"on:\") || name.startsWith(\"on-window:\") || name.startsWith(\"on-document:\")) {\n            const urls = value.split(\"\\n\");\n            for (const url of urls) {\n                const qrl = parseQRL(url, containerEl);\n                qrl.$capture$ && inflateQrl(qrl, elCtx), listeners.push([ name, qrl ]);\n            }\n        }\n    }\n    return listeners;\n};\n\nfunction isElement(value) {\n    return isNode(value) && 1 === value.nodeType;\n}\n\nfunction isNode(value) {\n    return value && \"number\" == typeof value.nodeType;\n}\n\nconst QObjectRecursive = 1;\n\nconst QObjectImmutable = 2;\n\nconst QOjectTargetSymbol = Symbol(\"proxy target\");\n\nconst QObjectFlagsSymbol = Symbol(\"proxy flags\");\n\nconst QObjectManagerSymbol = Symbol(\"proxy manager\");\n\nconst _IMMUTABLE = Symbol(\"IMMUTABLE\");\n\nconst _IMMUTABLE_PREFIX = \"$$\";\n\nconst _fnSignal = (fn, args, fnStr) => new SignalDerived(fn, args, fnStr);\n\nconst serializeDerivedSignalFunc = signal => {\n    const fnBody = signal.$funcStr$;\n    assertDefined(fnBody, \"If qSerialize is true then fnStr must be provided.\");\n    let args = \"\";\n    for (let i = 0; i < signal.$args$.length; i++) {\n        args += `p${i},`;\n    }\n    return `(${args})=>(${fnBody})`;\n};\n\nvar _a$1;\n\nconst _createSignal = (value, containerState, flags, subscriptions) => {\n    const manager = containerState.$subsManager$.$createManager$(subscriptions);\n    return new SignalImpl(value, manager, flags);\n};\n\nconst QObjectSignalFlags = Symbol(\"proxy manager\");\n\nconst SIGNAL_IMMUTABLE = 1;\n\nconst SIGNAL_UNASSIGNED = 2;\n\nconst SignalUnassignedException = Symbol(\"unassigned signal\");\n\nclass SignalBase {}\n\nclass SignalImpl extends SignalBase {\n    constructor(v, manager, flags) {\n        super(), this[_a$1] = 0, this.untrackedValue = v, this[QObjectManagerSymbol] = manager, \n        this[QObjectSignalFlags] = flags;\n    }\n    valueOf() {\n        qDev;\n    }\n    toString() {\n        return `[Signal ${String(this.value)}]`;\n    }\n    toJSON() {\n        return {\n            value: this.value\n        };\n    }\n    get value() {\n        if (2 & this[QObjectSignalFlags]) {\n            throw SignalUnassignedException;\n        }\n        const sub = tryGetInvokeContext()?.$subscriber$;\n        return sub && this[QObjectManagerSymbol].$addSub$(sub), this.untrackedValue;\n    }\n    set value(v) {\n        const manager = this[QObjectManagerSymbol];\n        manager && this.untrackedValue !== v && (this.untrackedValue = v, manager.$notifySubs$());\n    }\n}\n\n_a$1 = QObjectSignalFlags;\n\nclass SignalDerived extends SignalBase {\n    constructor($func$, $args$, $funcStr$) {\n        super(), this.$func$ = $func$, this.$args$ = $args$, this.$funcStr$ = $funcStr$;\n    }\n    get value() {\n        return this.$func$.apply(void 0, this.$args$);\n    }\n}\n\nclass SignalWrapper extends SignalBase {\n    constructor(ref, prop) {\n        super(), this.ref = ref, this.prop = prop;\n    }\n    get [QObjectManagerSymbol]() {\n        return getSubscriptionManager(this.ref);\n    }\n    get value() {\n        return this.ref[this.prop];\n    }\n    set value(value) {\n        this.ref[this.prop] = value;\n    }\n}\n\nconst isSignal = obj => obj instanceof SignalBase;\n\nconst _wrapProp = (obj, prop) => {\n    if (!isObject(obj)) {\n        return obj[prop];\n    }\n    if (obj instanceof SignalBase) {\n        return assertEqual(prop, \"value\", \"Left side is a signal, prop must be value\"), \n        obj;\n    }\n    const target = getProxyTarget(obj);\n    if (target) {\n        const signal = target[\"$$\" + prop];\n        if (signal) {\n            return assertTrue(isSignal(signal), \"$$ has to be a signal kind\"), signal;\n        }\n        if (!0 !== target[_IMMUTABLE]?.[prop]) {\n            return new SignalWrapper(obj, prop);\n        }\n    }\n    const immutable = obj[_IMMUTABLE]?.[prop];\n    return isSignal(immutable) ? immutable : _IMMUTABLE;\n};\n\nconst _wrapSignal = (obj, prop) => {\n    const r = _wrapProp(obj, prop);\n    return r === _IMMUTABLE ? obj[prop] : r;\n};\n\nconst getOrCreateProxy = (target, containerState, flags = 0) => {\n    const proxy = containerState.$proxyMap$.get(target);\n    return proxy || (0 !== flags && setObjectFlags(target, flags), createProxy(target, containerState, void 0));\n};\n\nconst createProxy = (target, containerState, subs) => {\n    assertEqual(unwrapProxy(target), target, \"Unexpected proxy at this location\", target), \n    assertTrue(!containerState.$proxyMap$.has(target), \"Proxy was already created\", target), \n    assertTrue(isObject(target), \"Target must be an object\"), assertTrue(isSerializableObject(target) || isArray(target), \"Target must be a serializable object\");\n    const manager = containerState.$subsManager$.$createManager$(subs);\n    const proxy = new Proxy(target, new ReadWriteProxyHandler(containerState, manager));\n    return containerState.$proxyMap$.set(target, proxy), proxy;\n};\n\nconst createPropsState = () => {\n    const props = {};\n    return setObjectFlags(props, 2), props;\n};\n\nconst setObjectFlags = (obj, flags) => {\n    Object.defineProperty(obj, QObjectFlagsSymbol, {\n        value: flags,\n        enumerable: !1\n    });\n};\n\nconst _restProps = (props, omit) => {\n    const rest = {};\n    for (const key in props) {\n        omit.includes(key) || (rest[key] = props[key]);\n    }\n    return rest;\n};\n\nclass ReadWriteProxyHandler {\n    constructor($containerState$, $manager$) {\n        this.$containerState$ = $containerState$, this.$manager$ = $manager$;\n    }\n    deleteProperty(target, prop) {\n        if (2 & target[QObjectFlagsSymbol]) {\n            throw qError(17);\n        }\n        return \"string\" == typeof prop && delete target[prop] && (this.$manager$.$notifySubs$(isArray(target) ? void 0 : prop), \n        !0);\n    }\n    get(target, prop) {\n        if (\"symbol\" == typeof prop) {\n            return prop === QOjectTargetSymbol ? target : prop === QObjectManagerSymbol ? this.$manager$ : target[prop];\n        }\n        const flags = target[QObjectFlagsSymbol] ?? 0;\n        assertNumber(flags, \"flags must be an number\");\n        const invokeCtx = tryGetInvokeContext();\n        const recursive = 0 != (1 & flags);\n        const hiddenSignal = target[\"$$\" + prop];\n        let subscriber;\n        let value;\n        if (invokeCtx && (subscriber = invokeCtx.$subscriber$), !(0 != (2 & flags)) || prop in target && !immutableValue(target[_IMMUTABLE]?.[prop]) || (subscriber = null), \n        hiddenSignal ? (assertTrue(isSignal(hiddenSignal), \"$$ prop must be a signal\"), \n        value = hiddenSignal.value, subscriber = null) : value = target[prop], subscriber) {\n            const isA = isArray(target);\n            this.$manager$.$addSub$(subscriber, isA ? void 0 : prop);\n        }\n        return recursive ? wrap(value, this.$containerState$) : value;\n    }\n    set(target, prop, newValue) {\n        if (\"symbol\" == typeof prop) {\n            return target[prop] = newValue, !0;\n        }\n        const flags = target[QObjectFlagsSymbol] ?? 0;\n        assertNumber(flags, \"flags must be an number\");\n        if (0 != (2 & flags)) {\n            throw qError(17);\n        }\n        const unwrappedNewValue = 0 != (1 & flags) ? unwrapProxy(newValue) : newValue;\n        if (isArray(target)) {\n            return target[prop] = unwrappedNewValue, this.$manager$.$notifySubs$(), !0;\n        }\n        const oldValue = target[prop];\n        return target[prop] = unwrappedNewValue, oldValue !== unwrappedNewValue && this.$manager$.$notifySubs$(prop), \n        !0;\n    }\n    has(target, property) {\n        if (property === QOjectTargetSymbol) {\n            return !0;\n        }\n        const hasOwnProperty = Object.prototype.hasOwnProperty;\n        return !!hasOwnProperty.call(target, property) || !(\"string\" != typeof property || !hasOwnProperty.call(target, \"$$\" + property));\n    }\n    ownKeys(target) {\n        const flags = target[QObjectFlagsSymbol] ?? 0;\n        assertNumber(flags, \"flags must be an number\");\n        if (!(0 != (2 & flags))) {\n            let subscriber = null;\n            const invokeCtx = tryGetInvokeContext();\n            invokeCtx && (subscriber = invokeCtx.$subscriber$), subscriber && this.$manager$.$addSub$(subscriber);\n        }\n        return isArray(target) ? Reflect.ownKeys(target) : Reflect.ownKeys(target).map((a => \"string\" == typeof a && a.startsWith(\"$$\") ? a.slice(2) : a));\n    }\n    getOwnPropertyDescriptor(target, prop) {\n        return isArray(target) || \"symbol\" == typeof prop ? Object.getOwnPropertyDescriptor(target, prop) : {\n            enumerable: !0,\n            configurable: !0\n        };\n    }\n}\n\nconst immutableValue = value => value === _IMMUTABLE || isSignal(value);\n\nconst wrap = (value, containerState) => {\n    if (isObject(value)) {\n        if (Object.isFrozen(value)) {\n            return value;\n        }\n        const nakedValue = unwrapProxy(value);\n        if (nakedValue !== value) {\n            return value;\n        }\n        if (fastSkipSerialize(nakedValue)) {\n            return value;\n        }\n        if (isSerializableObject(nakedValue) || isArray(nakedValue)) {\n            const proxy = containerState.$proxyMap$.get(nakedValue);\n            return proxy || getOrCreateProxy(nakedValue, containerState, 1);\n        }\n    }\n    return value;\n};\n\nconst Q_CTX = \"_qc_\";\n\nconst HOST_FLAG_DIRTY = 1;\n\nconst HOST_FLAG_NEED_ATTACH_LISTENER = 2;\n\nconst HOST_FLAG_MOUNTED = 4;\n\nconst HOST_FLAG_DYNAMIC = 8;\n\nconst tryGetContext = element => element[Q_CTX];\n\nconst getContext = (el, containerState) => {\n    assertQwikElement(el);\n    const ctx = tryGetContext(el);\n    if (ctx) {\n        return ctx;\n    }\n    const elCtx = createContext(el);\n    const elementID = directGetAttribute(el, \"q:id\");\n    if (elementID) {\n        const pauseCtx = containerState.$pauseCtx$;\n        if (elCtx.$id$ = elementID, pauseCtx) {\n            const {getObject, meta, refs} = pauseCtx;\n            if (isElement(el)) {\n                const refMap = refs[elementID];\n                refMap && (assertTrue(isElement(el), \"el must be an actual DOM element\"), elCtx.$refMap$ = refMap.split(\" \").map(getObject), \n                elCtx.li = getDomListeners(elCtx, containerState.$containerEl$));\n            } else {\n                const styleIds = el.getAttribute(\"q:sstyle\");\n                elCtx.$scopeIds$ = styleIds ? styleIds.split(\"|\") : null;\n                const ctxMeta = meta[elementID];\n                if (ctxMeta) {\n                    const seq = ctxMeta.s;\n                    const host = ctxMeta.h;\n                    const contexts = ctxMeta.c;\n                    const tasks = ctxMeta.w;\n                    if (seq && (elCtx.$seq$ = seq.split(\" \").map(getObject)), tasks && (elCtx.$tasks$ = tasks.split(\" \").map(getObject)), \n                    contexts) {\n                        elCtx.$contexts$ = new Map;\n                        for (const part of contexts.split(\" \")) {\n                            const [key, value] = part.split(\"=\");\n                            elCtx.$contexts$.set(key, getObject(value));\n                        }\n                    }\n                    if (host) {\n                        const [renderQrl, props] = host.split(\" \");\n                        if (elCtx.$flags$ = 4, renderQrl && (elCtx.$componentQrl$ = getObject(renderQrl)), \n                        props) {\n                            const propsObj = getObject(props);\n                            elCtx.$props$ = propsObj, setObjectFlags(propsObj, 2), propsObj[_IMMUTABLE] = getImmutableFromProps(propsObj);\n                        } else {\n                            elCtx.$props$ = createProxy(createPropsState(), containerState);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return elCtx;\n};\n\nconst getImmutableFromProps = props => {\n    const immutable = {};\n    const target = getProxyTarget(props);\n    for (const key in target) {\n        key.startsWith(\"$$\") && (immutable[key.slice(2)] = target[key]);\n    }\n    return immutable;\n};\n\nconst createContext = element => {\n    const ctx = {\n        $flags$: 0,\n        $id$: \"\",\n        $element$: element,\n        $refMap$: [],\n        li: [],\n        $tasks$: null,\n        $seq$: null,\n        $slots$: null,\n        $scopeIds$: null,\n        $appendStyles$: null,\n        $props$: null,\n        $vdom$: null,\n        $componentQrl$: null,\n        $contexts$: null,\n        $dynamicSlots$: null,\n        $parent$: null,\n        $slotParent$: null\n    };\n    return seal(), element[Q_CTX] = ctx, ctx;\n};\n\nconst cleanupContext = (elCtx, subsManager) => {\n    elCtx.$tasks$?.forEach((task => {\n        subsManager.$clearSub$(task), destroyTask(task);\n    })), elCtx.$componentQrl$ = null, elCtx.$seq$ = null, elCtx.$tasks$ = null;\n};\n\nlet _locale;\n\nfunction getLocale(defaultLocale) {\n    if (void 0 === _locale) {\n        const ctx = tryGetInvokeContext();\n        if (ctx && ctx.$locale$) {\n            return ctx.$locale$;\n        }\n        if (void 0 !== defaultLocale) {\n            return defaultLocale;\n        }\n        throw new Error(\"Reading `locale` outside of context.\");\n    }\n    return _locale;\n}\n\nfunction withLocale(locale, fn) {\n    const previousLang = _locale;\n    try {\n        return _locale = locale, fn();\n    } finally {\n        _locale = previousLang;\n    }\n}\n\nfunction setLocale(locale) {\n    _locale = locale;\n}\n\nlet _context;\n\nconst tryGetInvokeContext = () => {\n    if (!_context) {\n        const context = \"undefined\" != typeof document && document && document.__q_context__;\n        if (!context) {\n            return;\n        }\n        return isArray(context) ? document.__q_context__ = newInvokeContextFromTuple(context) : context;\n    }\n    return _context;\n};\n\nconst getInvokeContext = () => {\n    const ctx = tryGetInvokeContext();\n    if (!ctx) {\n        throw qError(14);\n    }\n    return ctx;\n};\n\nconst useInvokeContext = () => {\n    const ctx = tryGetInvokeContext();\n    if (!ctx || \"qRender\" !== ctx.$event$) {\n        throw qError(20);\n    }\n    return assertDefined(ctx.$hostElement$, \"invoke: $hostElement$ must be defined\", ctx), \n    assertDefined(ctx.$waitOn$, \"invoke: $waitOn$ must be defined\", ctx), assertDefined(ctx.$renderCtx$, \"invoke: $renderCtx$ must be defined\", ctx), \n    assertDefined(ctx.$subscriber$, \"invoke: $subscriber$ must be defined\", ctx), ctx;\n};\n\nconst useBindInvokeContext = callback => {\n    if (null == callback) {\n        return callback;\n    }\n    const ctx = getInvokeContext();\n    return (...args) => invoke(ctx, callback.bind(void 0, ...args));\n};\n\nfunction invoke(context, fn, ...args) {\n    const previousContext = _context;\n    let returnValue;\n    try {\n        _context = context, returnValue = fn.apply(this, args);\n    } finally {\n        _context = previousContext;\n    }\n    return returnValue;\n}\n\nconst waitAndRun = (ctx, callback) => {\n    const waitOn = ctx.$waitOn$;\n    if (0 === waitOn.length) {\n        const result = callback();\n        isPromise(result) && waitOn.push(result);\n    } else {\n        waitOn.push(Promise.all(waitOn).then(callback));\n    }\n};\n\nconst newInvokeContextFromTuple = context => {\n    const element = context[0];\n    const container = element.closest(\"[q\\\\:container]\");\n    const locale = container?.getAttribute(\"q:locale\") || void 0;\n    return locale && setLocale(locale), newInvokeContext(locale, void 0, element, context[1], context[2]);\n};\n\nconst newInvokeContext = (locale, hostElement, element, event, url) => {\n    const ctx = {\n        $seq$: 0,\n        $hostElement$: hostElement,\n        $element$: element,\n        $event$: event,\n        $url$: url,\n        $locale$: locale,\n        $qrl$: void 0,\n        $renderCtx$: void 0,\n        $subscriber$: void 0,\n        $waitOn$: void 0\n    };\n    return seal(), ctx;\n};\n\nconst getWrappingContainer = el => el.closest(\"[q\\\\:container]\");\n\nconst untrack = fn => invoke(void 0, fn);\n\nconst trackInvocation = /*#__PURE__*/ newInvokeContext(void 0, void 0, void 0, \"qRender\");\n\nconst trackSignal = (signal, sub) => (trackInvocation.$subscriber$ = sub, invoke(trackInvocation, (() => signal.value)));\n\nconst _getContextElement = () => {\n    const iCtx = tryGetInvokeContext();\n    if (iCtx) {\n        return iCtx.$element$ ?? iCtx.$hostElement$ ?? iCtx.$qrl$?.$setContainer$(void 0);\n    }\n};\n\nconst _getContextEvent = () => {\n    const iCtx = tryGetInvokeContext();\n    if (iCtx) {\n        return iCtx.$event$;\n    }\n};\n\nconst _jsxBranch = input => {\n    const iCtx = tryGetInvokeContext();\n    if (iCtx && iCtx.$hostElement$ && iCtx.$renderCtx$) {\n        getContext(iCtx.$hostElement$, iCtx.$renderCtx$.$static$.$containerState$).$flags$ |= 8;\n    }\n    return input;\n};\n\nconst _waitUntilRendered = elm => {\n    const containerEl = getWrappingContainer(elm);\n    if (!containerEl) {\n        return Promise.resolve();\n    }\n    return _getContainerState(containerEl).$renderPromise$ ?? Promise.resolve();\n};\n\nconst useOn = (event, eventQrl) => {\n    _useOn(createEventName(event, void 0), eventQrl);\n};\n\nconst useOnDocument = (event, eventQrl) => {\n    _useOn(createEventName(event, \"document\"), eventQrl);\n};\n\nconst useOnWindow = (event, eventQrl) => {\n    _useOn(createEventName(event, \"window\"), eventQrl);\n};\n\nconst createEventName = (event, eventType) => {\n    const formattedEventType = void 0 !== eventType ? eventType + \":\" : \"\";\n    return Array.isArray(event) ? event.map((e => `${formattedEventType}on-${e}`)) : `${formattedEventType}on-${event}`;\n};\n\nconst _useOn = (eventName, eventQrl) => {\n    if (eventQrl) {\n        const invokeCtx = useInvokeContext();\n        const elCtx = getContext(invokeCtx.$hostElement$, invokeCtx.$renderCtx$.$static$.$containerState$);\n        assertQrl(eventQrl), \"string\" == typeof eventName ? elCtx.li.push([ normalizeOnProp(eventName), eventQrl ]) : elCtx.li.push(...eventName.map((name => [ normalizeOnProp(name), eventQrl ]))), \n        elCtx.$flags$ |= 2;\n    }\n};\n\nconst SkipRender = Symbol(\"skip render\");\n\nconst SSRRaw = () => null;\n\nconst SSRComment = props => jsx(SSRRaw, {\n    data: `\\x3c!--${props.data}--\\x3e`\n}, null);\n\nconst SSRStreamBlock = props => [ jsx(SSRComment, {\n    data: \"qkssr-pu\"\n}), props.children, jsx(SSRComment, {\n    data: \"qkssr-po\"\n}) ];\n\nconst SSRStream = (props, key) => jsx(RenderOnce, {\n    children: jsx(InternalSSRStream, props)\n}, key);\n\nconst SSRHint = () => null;\n\nconst InternalSSRStream = () => null;\n\nconst useSequentialScope = () => {\n    const iCtx = useInvokeContext();\n    const i = iCtx.$seq$;\n    const elCtx = getContext(iCtx.$hostElement$, iCtx.$renderCtx$.$static$.$containerState$);\n    const seq = elCtx.$seq$ ? elCtx.$seq$ : elCtx.$seq$ = [];\n    iCtx.$seq$++;\n    return {\n        get: seq[i],\n        set: value => seq[i] = value,\n        i,\n        iCtx,\n        elCtx\n    };\n};\n\nconst setAttribute = (staticCtx, el, prop, value) => {\n    staticCtx.$operations$.push({\n        $operation$: _setAttribute,\n        $args$: [ el, prop, value ]\n    });\n};\n\nconst _setAttribute = (el, prop, value) => {\n    if (null == value || !1 === value) {\n        el.removeAttribute(prop);\n    } else {\n        const str = !0 === value ? \"\" : String(value);\n        directSetAttribute(el, prop, str);\n    }\n};\n\nconst setProperty = (staticCtx, node, key, value) => {\n    staticCtx.$operations$.push({\n        $operation$: _setProperty,\n        $args$: [ node, key, value ]\n    });\n};\n\nconst setPropertyPost = (staticCtx, node, key, value) => {\n    staticCtx.$postOperations$.push({\n        $operation$: _setProperty,\n        $args$: [ node, key, value ]\n    });\n};\n\nconst _setProperty = (node, key, value) => {\n    try {\n        node[key] = null == value ? \"\" : value, null == value && isNode$1(node) && isElement$1(node) && node.removeAttribute(key);\n    } catch (err) {\n        logError(codeToText(6), {\n            node,\n            key,\n            value\n        }, err);\n    }\n};\n\nconst createElement = (doc, expectTag, isSvg) => isSvg ? doc.createElementNS(SVG_NS, expectTag) : doc.createElement(expectTag);\n\nconst insertBefore = (staticCtx, parent, newChild, refChild) => (staticCtx.$operations$.push({\n    $operation$: directInsertBefore,\n    $args$: [ parent, newChild, refChild || null ]\n}), newChild);\n\nconst insertAfter = (staticCtx, parent, newChild, refChild) => (staticCtx.$operations$.push({\n    $operation$: directInsertAfter,\n    $args$: [ parent, newChild, refChild || null ]\n}), newChild);\n\nconst appendChild = (staticCtx, parent, newChild) => (staticCtx.$operations$.push({\n    $operation$: directAppendChild,\n    $args$: [ parent, newChild ]\n}), newChild);\n\nconst appendHeadStyle = (staticCtx, styleTask) => {\n    staticCtx.$containerState$.$styleIds$.add(styleTask.styleId), staticCtx.$postOperations$.push({\n        $operation$: _appendHeadStyle,\n        $args$: [ staticCtx.$containerState$, styleTask ]\n    });\n};\n\nconst _appendHeadStyle = (containerState, styleTask) => {\n    const containerEl = containerState.$containerEl$;\n    const doc = getDocument(containerEl);\n    const isDoc = doc.documentElement === containerEl;\n    const headEl = doc.head;\n    const style = doc.createElement(\"style\");\n    isDoc && !headEl && logWarn(\"document.head is undefined\"), directSetAttribute(style, QStyle, styleTask.styleId), \n    directSetAttribute(style, \"hidden\", \"\"), style.textContent = styleTask.content, \n    isDoc && headEl ? directAppendChild(headEl, style) : directInsertBefore(containerEl, style, containerEl.firstChild);\n};\n\nconst prepend = (staticCtx, parent, newChild) => {\n    staticCtx.$operations$.push({\n        $operation$: directPrepend,\n        $args$: [ parent, newChild ]\n    });\n};\n\nconst directPrepend = (parent, newChild) => {\n    directInsertBefore(parent, newChild, parent.firstChild);\n};\n\nconst removeNode = (staticCtx, el) => {\n    if (isQwikElement(el)) {\n        cleanupTree(el, staticCtx, staticCtx.$containerState$.$subsManager$, !0);\n    }\n    staticCtx.$operations$.push({\n        $operation$: _removeNode,\n        $args$: [ el, staticCtx ]\n    });\n};\n\nconst _removeNode = el => {\n    const parent = el.parentElement;\n    parent && directRemoveChild(parent, el);\n};\n\nconst createTemplate = (doc, slotName) => {\n    const template = createElement(doc, \"q:template\", !1);\n    return directSetAttribute(template, QSlot, slotName), directSetAttribute(template, \"hidden\", \"\"), \n    directSetAttribute(template, \"aria-hidden\", \"true\"), template;\n};\n\nconst executeDOMRender = staticCtx => {\n    for (const op of staticCtx.$operations$) {\n        op.$operation$.apply(void 0, op.$args$);\n    }\n    resolveSlotProjection(staticCtx);\n};\n\nconst getKey = el => directGetAttribute(el, \"q:key\");\n\nconst setKey = (el, key) => {\n    null !== key && directSetAttribute(el, \"q:key\", key);\n};\n\nconst resolveSlotProjection = staticCtx => {\n    const subsManager = staticCtx.$containerState$.$subsManager$;\n    for (const slotEl of staticCtx.$rmSlots$) {\n        const key = getKey(slotEl);\n        assertDefined(key, \"slots must have a key\");\n        const slotChildren = getChildren(slotEl, isChildComponent);\n        if (slotChildren.length > 0) {\n            const sref = slotEl.getAttribute(\"q:sref\");\n            const hostCtx = staticCtx.$roots$.find((r => r.$id$ === sref));\n            if (hostCtx) {\n                const hostElm = hostCtx.$element$;\n                if (hostElm.isConnected) {\n                    if (getChildren(hostElm, isSlotTemplate).some((node => directGetAttribute(node, QSlot) === key))) {\n                        cleanupTree(slotEl, staticCtx, subsManager, !1);\n                    } else {\n                        const template = createTemplate(staticCtx.$doc$, key);\n                        for (const child of slotChildren) {\n                            directAppendChild(template, child);\n                        }\n                        directInsertBefore(hostElm, template, hostElm.firstChild);\n                    }\n                } else {\n                    cleanupTree(slotEl, staticCtx, subsManager, !1);\n                }\n            } else {\n                cleanupTree(slotEl, staticCtx, subsManager, !1);\n            }\n        }\n    }\n    for (const [slotEl, hostElm] of staticCtx.$addSlots$) {\n        const key = getKey(slotEl);\n        assertDefined(key, \"slots must have a key\");\n        const template = getChildren(hostElm, isSlotTemplate).find((node => node.getAttribute(QSlot) === key));\n        template && (getChildren(template, isChildComponent).forEach((child => {\n            directAppendChild(slotEl, child);\n        })), template.remove());\n    }\n};\n\nconst printRenderStats = () => {\n    qDev;\n};\n\nconst VIRTUAL_SYMBOL = \"__virtual\";\n\nconst newVirtualElement = (doc, isSvg) => {\n    const open = doc.createComment(\"qv \");\n    const close = doc.createComment(\"/qv\");\n    return new VirtualElementImpl(open, close, isSvg);\n};\n\nconst parseVirtualAttributes = str => {\n    if (!str) {\n        return {};\n    }\n    const attributes = str.split(\" \");\n    return Object.fromEntries(attributes.map((attr => {\n        const index = attr.indexOf(\"=\");\n        return index >= 0 ? [ attr.slice(0, index), unescape(attr.slice(index + 1)) ] : [ attr, \"\" ];\n    })));\n};\n\nconst serializeVirtualAttributes = map => {\n    const attributes = [];\n    return Object.entries(map).forEach((([key, value]) => {\n        attributes.push(value ? `${key}=${escape(value)}` : `${key}`);\n    })), attributes.join(\" \");\n};\n\nconst SHOW_COMMENT = 128;\n\nconst FILTER_ACCEPT = 1;\n\nconst FILTER_REJECT = 2;\n\nconst walkerVirtualByAttribute = (el, prop, value) => el.ownerDocument.createTreeWalker(el, 128, {\n    acceptNode(c) {\n        const virtual = getVirtualElement(c);\n        return virtual && directGetAttribute(virtual, prop) === value ? 1 : 2;\n    }\n});\n\nconst queryAllVirtualByAttribute = (el, prop, value) => {\n    const walker = walkerVirtualByAttribute(el, prop, value);\n    const pars = [];\n    let currentNode = null;\n    for (;currentNode = walker.nextNode(); ) {\n        pars.push(getVirtualElement(currentNode));\n    }\n    return pars;\n};\n\nconst escape = s => s.replace(/ /g, \"+\");\n\nconst unescape = s => s.replace(/\\+/g, \" \");\n\nconst VIRTUAL = \":virtual\";\n\nclass VirtualElementImpl {\n    constructor(open, close, isSvg) {\n        this.open = open, this.close = close, this.isSvg = isSvg, this._qc_ = null, this.nodeType = 111, \n        this.localName = VIRTUAL, this.nodeName = VIRTUAL;\n        const doc = this.ownerDocument = open.ownerDocument;\n        this.$template$ = createElement(doc, \"template\", !1), this.$attributes$ = parseVirtualAttributes(open.data.slice(3)), \n        assertTrue(open.data.startsWith(\"qv \"), \"comment is not a qv\"), open.__virtual = this, \n        seal();\n    }\n    insertBefore(node, ref) {\n        const parent = this.parentElement;\n        if (parent) {\n            parent.insertBefore(node, ref || this.close);\n        } else {\n            this.$template$.insertBefore(node, ref);\n        }\n        return node;\n    }\n    remove() {\n        const parent = this.parentElement;\n        if (parent) {\n            const ch = this.childNodes;\n            assertEqual(this.$template$.childElementCount, 0, \"children should be empty\"), parent.removeChild(this.open);\n            for (let i = 0; i < ch.length; i++) {\n                this.$template$.appendChild(ch[i]);\n            }\n            parent.removeChild(this.close);\n        }\n    }\n    appendChild(node) {\n        return this.insertBefore(node, null);\n    }\n    insertBeforeTo(newParent, child) {\n        const ch = this.childNodes;\n        newParent.insertBefore(this.open, child);\n        for (const c of ch) {\n            newParent.insertBefore(c, child);\n        }\n        newParent.insertBefore(this.close, child), assertEqual(this.$template$.childElementCount, 0, \"children should be empty\");\n    }\n    appendTo(newParent) {\n        this.insertBeforeTo(newParent, null);\n    }\n    get namespaceURI() {\n        return this.parentElement?.namespaceURI ?? \"\";\n    }\n    removeChild(child) {\n        this.parentElement ? this.parentElement.removeChild(child) : this.$template$.removeChild(child);\n    }\n    getAttribute(prop) {\n        return this.$attributes$[prop] ?? null;\n    }\n    hasAttribute(prop) {\n        return prop in this.$attributes$;\n    }\n    setAttribute(prop, value) {\n        this.$attributes$[prop] = value, this.open.data = updateComment(this.$attributes$);\n    }\n    removeAttribute(prop) {\n        delete this.$attributes$[prop], this.open.data = updateComment(this.$attributes$);\n    }\n    matches(_) {\n        return !1;\n    }\n    compareDocumentPosition(other) {\n        return this.open.compareDocumentPosition(other);\n    }\n    closest(query) {\n        const parent = this.parentElement;\n        return parent ? parent.closest(query) : null;\n    }\n    querySelectorAll(query) {\n        const result = [];\n        return getChildren(this, isNodeElement).forEach((el => {\n            isQwikElement(el) && (el.matches(query) && result.push(el), result.concat(Array.from(el.querySelectorAll(query))));\n        })), result;\n    }\n    querySelector(query) {\n        for (const el of this.childNodes) {\n            if (isElement$1(el)) {\n                if (el.matches(query)) {\n                    return el;\n                }\n                const v = el.querySelector(query);\n                if (null !== v) {\n                    return v;\n                }\n            }\n        }\n        return null;\n    }\n    get innerHTML() {\n        return \"\";\n    }\n    set innerHTML(html) {\n        const parent = this.parentElement;\n        parent ? (this.childNodes.forEach((a => this.removeChild(a))), this.$template$.innerHTML = html, \n        parent.insertBefore(this.$template$.content, this.close)) : this.$template$.innerHTML = html;\n    }\n    get firstChild() {\n        if (this.parentElement) {\n            const first = this.open.nextSibling;\n            return first === this.close ? null : first;\n        }\n        return this.$template$.firstChild;\n    }\n    get nextSibling() {\n        return this.close.nextSibling;\n    }\n    get previousSibling() {\n        return this.open.previousSibling;\n    }\n    get childNodes() {\n        if (!this.parentElement) {\n            return Array.from(this.$template$.childNodes);\n        }\n        const nodes = [];\n        let node = this.open;\n        for (;(node = node.nextSibling) && node !== this.close; ) {\n            nodes.push(node);\n        }\n        return nodes;\n    }\n    get isConnected() {\n        return this.open.isConnected;\n    }\n    get parentElement() {\n        return this.open.parentElement;\n    }\n}\n\nconst updateComment = attributes => `qv ${serializeVirtualAttributes(attributes)}`;\n\nconst processVirtualNodes = node => {\n    if (null == node) {\n        return null;\n    }\n    if (isComment(node)) {\n        const virtual = getVirtualElement(node);\n        if (virtual) {\n            return virtual;\n        }\n    }\n    return node;\n};\n\nconst getVirtualElement = open => {\n    const virtual = open.__virtual;\n    if (virtual) {\n        return virtual;\n    }\n    if (open.data.startsWith(\"qv \")) {\n        const close = findClose(open);\n        return new VirtualElementImpl(open, close, open.parentElement?.namespaceURI === SVG_NS);\n    }\n    return null;\n};\n\nconst findClose = open => {\n    let node = open.nextSibling;\n    let stack = 1;\n    for (;node; ) {\n        if (isComment(node)) {\n            if (node.data.startsWith(\"qv \")) {\n                stack++;\n            } else if (\"/qv\" === node.data && (stack--, 0 === stack)) {\n                return node;\n            }\n        }\n        node = node.nextSibling;\n    }\n    assertFail(\"close not found\");\n};\n\nconst getRootNode = node => null == node ? null : isVirtualElement(node) ? node.open : node;\n\nconst createContextId = name => (assertTrue(/^[\\w/.-]+$/.test(name), \"Context name must only contain A-Z,a-z,0-9, _\", name), \n/*#__PURE__*/ Object.freeze({\n    id: fromCamelToKebabCase(name)\n}));\n\nconst useContextProvider = (context, newValue) => {\n    const {get, set, elCtx} = useSequentialScope();\n    if (void 0 !== get) {\n        return;\n    }\n    let contexts = elCtx.$contexts$;\n    contexts || (elCtx.$contexts$ = contexts = new Map), contexts.set(context.id, newValue), \n    set(!0);\n};\n\nconst useContext = (context, defaultValue) => {\n    const {get, set, iCtx, elCtx} = useSequentialScope();\n    if (void 0 !== get) {\n        return get;\n    }\n    const value = resolveContext(context, elCtx, iCtx.$renderCtx$.$static$.$containerState$);\n    if (\"function\" == typeof defaultValue) {\n        return set(invoke(void 0, defaultValue, value));\n    }\n    if (void 0 !== value) {\n        return set(value);\n    }\n    if (void 0 !== defaultValue) {\n        return set(defaultValue);\n    }\n    throw qError(13, context.id);\n};\n\nconst resolveContext = (context, hostCtx, containerState) => {\n    const contextID = context.id;\n    if (hostCtx) {\n        let hostElement = hostCtx.$element$;\n        let ctx = hostCtx.$slotParent$ ?? hostCtx.$parent$;\n        for (;ctx; ) {\n            if (hostElement = ctx.$element$, ctx.$contexts$) {\n                const found = ctx.$contexts$.get(contextID);\n                if (found) {\n                    return found;\n                }\n                if (!0 === ctx.$contexts$.get(\"_\")) {\n                    break;\n                }\n            }\n            ctx = ctx.$slotParent$ ?? ctx.$parent$;\n        }\n        if (hostElement.closest) {\n            const value = queryContextFromDom(hostElement, containerState, contextID);\n            if (void 0 !== value) {\n                return value;\n            }\n        }\n    }\n};\n\nconst queryContextFromDom = (hostElement, containerState, contextId) => {\n    let element = hostElement;\n    for (;element; ) {\n        let node = element;\n        let virtual;\n        for (;node && (virtual = findVirtual(node)); ) {\n            const contexts = getContext(virtual, containerState)?.$contexts$;\n            if (contexts && contexts.has(contextId)) {\n                return contexts.get(contextId);\n            }\n            node = virtual;\n        }\n        element = element.parentElement;\n    }\n};\n\nconst findVirtual = el => {\n    let node = el;\n    let stack = 1;\n    for (;node = node.previousSibling; ) {\n        if (isComment(node)) {\n            if (\"/qv\" === node.data) {\n                stack++;\n            } else if (node.data.startsWith(\"qv \") && (stack--, 0 === stack)) {\n                return getVirtualElement(node);\n            }\n        }\n    }\n    return null;\n};\n\nconst validateContext = context => {\n    if (!isObject(context) || \"string\" != typeof context.id || 0 === context.id.length) {\n        throw qError(28, context);\n    }\n};\n\nconst ERROR_CONTEXT = /*#__PURE__*/ createContextId(\"qk-error\");\n\nconst handleError = (err, hostElement, rCtx) => {\n    const elCtx = tryGetContext(hostElement);\n    if (isServerPlatform()) {\n        throw err;\n    }\n    {\n        const errorStore = resolveContext(ERROR_CONTEXT, elCtx, rCtx.$static$.$containerState$);\n        if (void 0 === errorStore) {\n            throw err;\n        }\n        errorStore.error = err;\n    }\n};\n\nconst isRecoverable = err => !(err && err instanceof Error && \"plugin\" in err);\n\nconst executeComponent = (rCtx, elCtx) => {\n    elCtx.$flags$ &= -2, elCtx.$flags$ |= 4, elCtx.$slots$ = [], elCtx.li.length = 0;\n    const hostElement = elCtx.$element$;\n    const componentQRL = elCtx.$componentQrl$;\n    const props = elCtx.$props$;\n    const newCtx = pushRenderContext(rCtx);\n    const iCtx = newInvokeContext(rCtx.$static$.$locale$, hostElement, void 0, \"qRender\");\n    const waitOn = iCtx.$waitOn$ = [];\n    assertDefined(componentQRL, \"render: host element to render must has a $renderQrl$:\", elCtx), \n    assertDefined(props, \"render: host element to render must has defined props\", elCtx), \n    newCtx.$cmpCtx$ = elCtx, newCtx.$slotCtx$ = null, iCtx.$subscriber$ = [ 0, hostElement ], \n    iCtx.$renderCtx$ = rCtx, componentQRL.$setContainer$(rCtx.$static$.$containerState$.$containerEl$);\n    const componentFn = componentQRL.getFn(iCtx);\n    return safeCall((() => componentFn(props)), (jsxNode => waitOn.length > 0 ? Promise.all(waitOn).then((() => 1 & elCtx.$flags$ ? executeComponent(rCtx, elCtx) : {\n        node: jsxNode,\n        rCtx: newCtx\n    })) : 1 & elCtx.$flags$ ? executeComponent(rCtx, elCtx) : {\n        node: jsxNode,\n        rCtx: newCtx\n    }), (err => err === SignalUnassignedException ? Promise.all(waitOn).then((() => executeComponent(rCtx, elCtx))) : (handleError(err, hostElement, rCtx), \n    {\n        node: SkipRender,\n        rCtx: newCtx\n    })));\n};\n\nconst createRenderContext = (doc, containerState) => {\n    const ctx = {\n        $static$: {\n            $doc$: doc,\n            $locale$: containerState.$serverData$.locale,\n            $containerState$: containerState,\n            $hostElements$: new Set,\n            $operations$: [],\n            $postOperations$: [],\n            $roots$: [],\n            $addSlots$: [],\n            $rmSlots$: [],\n            $visited$: []\n        },\n        $cmpCtx$: null,\n        $slotCtx$: null\n    };\n    return seal(), seal(), ctx;\n};\n\nconst pushRenderContext = ctx => ({\n    $static$: ctx.$static$,\n    $cmpCtx$: ctx.$cmpCtx$,\n    $slotCtx$: ctx.$slotCtx$\n});\n\nconst serializeClassWithHost = (obj, hostCtx) => hostCtx && hostCtx.$scopeIds$ ? hostCtx.$scopeIds$.join(\" \") + \" \" + serializeClass(obj) : serializeClass(obj);\n\nconst serializeClass = obj => obj ? isString(obj) ? obj.trim() : isArray(obj) ? obj.reduce(((result, o) => {\n    const classList = serializeClass(o);\n    return classList ? result ? `${result} ${classList}` : classList : result;\n}), \"\") : Object.entries(obj).reduce(((result, [key, value]) => value ? result ? `${result} ${key.trim()}` : key.trim() : result), \"\") : \"\";\n\nconst stringifyStyle = obj => {\n    if (null == obj) {\n        return \"\";\n    }\n    if (\"object\" == typeof obj) {\n        if (isArray(obj)) {\n            throw qError(0, obj, \"style\");\n        }\n        {\n            const chunks = [];\n            for (const key in obj) {\n                if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                    const value = obj[key];\n                    if (null != value) {\n                        const normalizedKey = key.startsWith(\"--\") ? key : fromCamelToKebabCase(key);\n                        chunks.push(normalizedKey + \":\" + value);\n                    }\n                }\n            }\n            return chunks.join(\";\");\n        }\n    }\n    return String(obj);\n};\n\nconst getNextIndex = ctx => intToStr(ctx.$static$.$containerState$.$elementIndex$++);\n\nconst setQId = (rCtx, elCtx) => {\n    const id = getNextIndex(rCtx);\n    elCtx.$id$ = id;\n};\n\nconst jsxToString = data => isSignal(data) ? jsxToString(data.value) : null == data || \"boolean\" == typeof data ? \"\" : String(data);\n\nfunction isAriaAttribute(prop) {\n    return prop.startsWith(\"aria-\");\n}\n\nconst shouldWrapFunctional = (res, node) => !!node.key && (!isJSXNode(res) || !isFunction(res.type) && res.key != node.key);\n\nconst static_listeners = 1;\n\nconst static_subtree = 2;\n\nconst dangerouslySetInnerHTML = \"dangerouslySetInnerHTML\";\n\nconst version = \"1.2.11\";\n\nconst hashCode = (text, hash = 0) => {\n    for (let i = 0; i < text.length; i++) {\n        hash = (hash << 5) - hash + text.charCodeAt(i), hash |= 0;\n    }\n    return Number(Math.abs(hash)).toString(36);\n};\n\nconst styleKey = (qStyles, index) => (assertQrl(qStyles), `${hashCode(qStyles.$hash$)}-${index}`);\n\nconst styleContent = styleId => \"⭐️\" + styleId;\n\nconst serializeSStyle = scopeIds => {\n    const value = scopeIds.join(\"|\");\n    if (value.length > 0) {\n        return value;\n    }\n};\n\nvar _a;\n\nconst FLUSH_COMMENT = \"\\x3c!--qkssr-f--\\x3e\";\n\nconst IS_HEAD$1 = 1;\n\nconst IS_HTML = 4;\n\nconst IS_TEXT = 8;\n\nconst IS_INVISIBLE = 16;\n\nconst IS_PHASING = 32;\n\nconst IS_ANCHOR = 64;\n\nconst IS_BUTTON = 128;\n\nconst IS_TABLE = 256;\n\nconst IS_PHRASING_CONTAINER = 512;\n\nconst IS_IMMUTABLE$1 = 1024;\n\nclass MockElement {\n    constructor(nodeType) {\n        this.nodeType = nodeType, this[_a] = null, seal();\n    }\n}\n\n_a = Q_CTX;\n\nconst createDocument = () => new MockElement(9);\n\nconst _renderSSR = async (node, opts) => {\n    const root = opts.containerTagName;\n    const containerEl = createSSRContext(1).$element$;\n    const containerState = createContainerState(containerEl, opts.base ?? \"/\");\n    containerState.$serverData$.locale = opts.serverData?.locale;\n    const doc = new MockElement(9);\n    const rCtx = createRenderContext(doc, containerState);\n    const headNodes = opts.beforeContent ?? [];\n    const ssrCtx = {\n        $static$: {\n            $contexts$: [],\n            $headNodes$: \"html\" === root ? headNodes : [],\n            $locale$: opts.serverData?.locale,\n            $textNodes$: new Map\n        },\n        $projectedChildren$: void 0,\n        $projectedCtxs$: void 0,\n        $invocationContext$: void 0\n    };\n    seal();\n    let qRender = \"ssr\";\n    opts.containerAttributes[\"q:render\"] && (qRender = `${opts.containerAttributes[\"q:render\"]}-${qRender}`);\n    const containerAttributes = {\n        ...opts.containerAttributes,\n        \"q:container\": \"paused\",\n        \"q:version\": \"1.2.11\",\n        \"q:render\": qRender,\n        \"q:base\": opts.base,\n        \"q:locale\": opts.serverData?.locale,\n        \"q:manifest-hash\": opts.manifestHash\n    };\n    const children = \"html\" === root ? [ node ] : [ headNodes, node ];\n    \"html\" !== root && (containerAttributes.class = \"qc📦\" + (containerAttributes.class ? \" \" + containerAttributes.class : \"\")), \n    opts.serverData && (containerState.$serverData$ = opts.serverData), node = _jsxQ(root, null, containerAttributes, children, 3, null), \n    containerState.$hostsRendering$ = new Set, await Promise.resolve().then((() => renderRoot$1(node, rCtx, ssrCtx, opts.stream, containerState, opts)));\n};\n\nconst renderRoot$1 = async (node, rCtx, ssrCtx, stream, containerState, opts) => {\n    const beforeClose = opts.beforeClose;\n    return await renderNode(node, rCtx, ssrCtx, stream, 0, beforeClose ? stream => {\n        const result = beforeClose(ssrCtx.$static$.$contexts$, containerState, !1, ssrCtx.$static$.$textNodes$);\n        return processData$1(result, rCtx, ssrCtx, stream, 0, void 0);\n    } : void 0), rCtx;\n};\n\nconst renderGenerator = async (node, rCtx, ssrCtx, stream, flags) => {\n    stream.write(FLUSH_COMMENT);\n    const generator = node.props.children;\n    let value;\n    if (isFunction(generator)) {\n        const v = generator({\n            write(chunk) {\n                stream.write(chunk), stream.write(FLUSH_COMMENT);\n            }\n        });\n        if (isPromise(v)) {\n            return v;\n        }\n        value = v;\n    } else {\n        value = generator;\n    }\n    for await (const chunk of value) {\n        await processData$1(chunk, rCtx, ssrCtx, stream, flags, void 0), stream.write(FLUSH_COMMENT);\n    }\n};\n\nconst renderNodeVirtual = (node, elCtx, extraNodes, rCtx, ssrCtx, stream, flags, beforeClose) => {\n    const props = node.props;\n    const renderQrl = props[\"q:renderFn\"];\n    if (renderQrl) {\n        return elCtx.$componentQrl$ = renderQrl, renderSSRComponent(rCtx, ssrCtx, stream, elCtx, node, flags, beforeClose);\n    }\n    let virtualComment = \"\\x3c!--qv\" + renderVirtualAttributes(props);\n    const isSlot = \"q:s\" in props;\n    const key = null != node.key ? String(node.key) : null;\n    isSlot && (assertDefined(rCtx.$cmpCtx$?.$id$, \"hostId must be defined for a slot\"), \n    virtualComment += \" q:sref=\" + rCtx.$cmpCtx$.$id$), null != key && (virtualComment += \" q:key=\" + key), \n    virtualComment += \"--\\x3e\", stream.write(virtualComment);\n    const html = node.props[dangerouslySetInnerHTML];\n    if (html) {\n        return stream.write(html), void stream.write(CLOSE_VIRTUAL);\n    }\n    if (extraNodes) {\n        for (const node of extraNodes) {\n            renderNodeElementSync(node.type, node.props, stream);\n        }\n    }\n    const promise = walkChildren(node.children, rCtx, ssrCtx, stream, flags);\n    return then(promise, (() => {\n        if (!isSlot && !beforeClose) {\n            return void stream.write(CLOSE_VIRTUAL);\n        }\n        let promise;\n        if (isSlot) {\n            assertDefined(key, \"key must be defined for a slot\");\n            const content = ssrCtx.$projectedChildren$?.[key];\n            if (content) {\n                const [rCtx, sCtx] = ssrCtx.$projectedCtxs$;\n                const newSlotRctx = pushRenderContext(rCtx);\n                newSlotRctx.$slotCtx$ = elCtx, ssrCtx.$projectedChildren$[key] = void 0, promise = processData$1(content, newSlotRctx, sCtx, stream, flags);\n            }\n        }\n        return beforeClose && (promise = then(promise, (() => beforeClose(stream)))), then(promise, (() => {\n            stream.write(CLOSE_VIRTUAL);\n        }));\n    }));\n};\n\nconst CLOSE_VIRTUAL = \"\\x3c!--/qv--\\x3e\";\n\nconst renderAttributes = attributes => {\n    let text = \"\";\n    for (const prop in attributes) {\n        if (prop === dangerouslySetInnerHTML) {\n            continue;\n        }\n        const value = attributes[prop];\n        null != value && (text += \" \" + (\"\" === value ? prop : prop + '=\"' + value + '\"'));\n    }\n    return text;\n};\n\nconst renderVirtualAttributes = attributes => {\n    let text = \"\";\n    for (const prop in attributes) {\n        if (\"children\" === prop || prop === dangerouslySetInnerHTML) {\n            continue;\n        }\n        const value = attributes[prop];\n        null != value && (text += \" \" + (\"\" === value ? prop : prop + \"=\" + value));\n    }\n    return text;\n};\n\nconst renderNodeElementSync = (tagName, attributes, stream) => {\n    stream.write(\"<\" + tagName + renderAttributes(attributes) + \">\");\n    if (!!emptyElements[tagName]) {\n        return;\n    }\n    const innerHTML = attributes[dangerouslySetInnerHTML];\n    null != innerHTML && stream.write(innerHTML), stream.write(`</${tagName}>`);\n};\n\nconst renderSSRComponent = (rCtx, ssrCtx, stream, elCtx, node, flags, beforeClose) => (setComponentProps$1(rCtx, elCtx, node.props.props), \nthen(executeComponent(rCtx, elCtx), (res => {\n    const hostElement = elCtx.$element$;\n    const newRCtx = res.rCtx;\n    const iCtx = newInvokeContext(ssrCtx.$static$.$locale$, hostElement, void 0);\n    iCtx.$subscriber$ = [ 0, hostElement ], iCtx.$renderCtx$ = newRCtx;\n    const newSSrContext = {\n        $static$: ssrCtx.$static$,\n        $projectedChildren$: splitProjectedChildren(node.children, ssrCtx),\n        $projectedCtxs$: [ rCtx, ssrCtx ],\n        $invocationContext$: iCtx\n    };\n    const extraNodes = [];\n    if (elCtx.$appendStyles$) {\n        const array = !!(4 & flags) ? ssrCtx.$static$.$headNodes$ : extraNodes;\n        for (const style of elCtx.$appendStyles$) {\n            array.push(_jsxQ(\"style\", {\n                [QStyle]: style.styleId,\n                [dangerouslySetInnerHTML]: style.content,\n                hidden: \"\"\n            }, null, null, 0, null));\n        }\n    }\n    const newID = getNextIndex(rCtx);\n    const scopeId = elCtx.$scopeIds$ ? serializeSStyle(elCtx.$scopeIds$) : void 0;\n    const processedNode = _jsxC(node.type, {\n        \"q:sstyle\": scopeId,\n        \"q:id\": newID,\n        children: res.node\n    }, 0, node.key);\n    return elCtx.$id$ = newID, ssrCtx.$static$.$contexts$.push(elCtx), renderNodeVirtual(processedNode, elCtx, extraNodes, newRCtx, newSSrContext, stream, flags, (stream => {\n        if (2 & elCtx.$flags$) {\n            const placeholderCtx = createSSRContext(1);\n            const listeners = placeholderCtx.li;\n            listeners.push(...elCtx.li), elCtx.$flags$ &= -3, placeholderCtx.$id$ = getNextIndex(rCtx);\n            const attributes = {\n                type: \"placeholder\",\n                hidden: \"\",\n                \"q:id\": placeholderCtx.$id$\n            };\n            ssrCtx.$static$.$contexts$.push(placeholderCtx);\n            const groups = groupListeners(listeners);\n            for (const listener of groups) {\n                const eventName = normalizeInvisibleEvents(listener[0]);\n                attributes[eventName] = serializeQRLs(listener[1], placeholderCtx), registerQwikEvent$1(eventName, rCtx.$static$.$containerState$);\n            }\n            renderNodeElementSync(\"script\", attributes, stream);\n        }\n        return beforeClose ? then(renderQTemplates(rCtx, newSSrContext, ssrCtx, stream), (() => beforeClose(stream))) : renderQTemplates(rCtx, newSSrContext, ssrCtx, stream);\n    }));\n})));\n\nconst renderQTemplates = (rCtx, ssrCtx, parentSSRCtx, stream) => {\n    const projectedChildren = ssrCtx.$projectedChildren$;\n    if (projectedChildren) {\n        const nodes = Object.keys(projectedChildren).map((slotName => {\n            const value = projectedChildren[slotName];\n            if (value) {\n                return _jsxQ(\"q:template\", {\n                    [QSlot]: slotName,\n                    hidden: \"\",\n                    \"aria-hidden\": \"true\"\n                }, null, value, 0, null);\n            }\n        }));\n        return processData$1(nodes, rCtx, parentSSRCtx, stream, 0, void 0);\n    }\n};\n\nconst splitProjectedChildren = (children, ssrCtx) => {\n    const flatChildren = flatVirtualChildren(children, ssrCtx);\n    if (null === flatChildren) {\n        return;\n    }\n    const slotMap = {};\n    for (const child of flatChildren) {\n        let slotName = \"\";\n        isJSXNode(child) && (slotName = child.props[QSlot] ?? \"\");\n        let array = slotMap[slotName];\n        array || (slotMap[slotName] = array = []), array.push(child);\n    }\n    return slotMap;\n};\n\nconst createSSRContext = nodeType => {\n    const elm = new MockElement(nodeType);\n    return createContext(elm);\n};\n\nconst renderNode = (node, rCtx, ssrCtx, stream, flags, beforeClose) => {\n    const tagName = node.type;\n    const hostCtx = rCtx.$cmpCtx$;\n    if (\"string\" == typeof tagName) {\n        const key = node.key;\n        const props = node.props;\n        const immutable = node.immutableProps;\n        const elCtx = createSSRContext(1);\n        const elm = elCtx.$element$;\n        const isHead = \"head\" === tagName;\n        let openingElement = \"<\" + tagName;\n        let useSignal = !1;\n        let hasRef = !1;\n        let classStr = \"\";\n        let htmlStr = null;\n        if (assertElement(elm), immutable) {\n            for (const prop in immutable) {\n                let value = immutable[prop];\n                if (isOnProp(prop)) {\n                    setEvent(elCtx.li, prop, value, void 0);\n                    continue;\n                }\n                const attrName = processPropKey(prop);\n                if (isSignal(value) && (assertDefined(hostCtx, \"Signals can not be used outside the root\"), \n                value = trackSignal(value, [ 1, elm, value, hostCtx.$element$, attrName ]), useSignal = !0), \n                prop === dangerouslySetInnerHTML) {\n                    htmlStr = value;\n                    continue;\n                }\n                prop.startsWith(PREVENT_DEFAULT) && registerQwikEvent$1(prop.slice(15), rCtx.$static$.$containerState$);\n                const attrValue = processPropValue(attrName, value);\n                null != attrValue && (\"class\" === attrName ? classStr = attrValue : \"value\" === attrName && \"textarea\" === tagName ? htmlStr = escapeHtml(attrValue) : isSSRUnsafeAttr(attrName) || (openingElement += \" \" + (\"\" === value ? attrName : attrName + '=\"' + escapeAttr(attrValue) + '\"')));\n            }\n        }\n        for (const prop in props) {\n            let value = props[prop];\n            if (\"ref\" === prop) {\n                void 0 !== value && (setRef(value, elm), hasRef = !0);\n                continue;\n            }\n            if (isOnProp(prop)) {\n                setEvent(elCtx.li, prop, value, void 0);\n                continue;\n            }\n            const attrName = processPropKey(prop);\n            if (isSignal(value) && (assertDefined(hostCtx, \"Signals can not be used outside the root\"), \n            value = trackSignal(value, [ 2, hostCtx.$element$, value, elm, attrName ]), useSignal = !0), \n            prop === dangerouslySetInnerHTML) {\n                htmlStr = value;\n                continue;\n            }\n            prop.startsWith(PREVENT_DEFAULT) && registerQwikEvent$1(prop.slice(15), rCtx.$static$.$containerState$);\n            const attrValue = processPropValue(attrName, value);\n            null != attrValue && (\"class\" === attrName ? classStr = attrValue : \"value\" === attrName && \"textarea\" === tagName ? htmlStr = escapeHtml(attrValue) : isSSRUnsafeAttr(attrName) || (openingElement += \" \" + (\"\" === value ? attrName : attrName + '=\"' + escapeAttr(attrValue) + '\"')));\n        }\n        const listeners = elCtx.li;\n        if (hostCtx) {\n            if (hostCtx.$scopeIds$?.length) {\n                const extra = hostCtx.$scopeIds$.join(\" \");\n                classStr = classStr ? `${extra} ${classStr}` : extra;\n            }\n            2 & hostCtx.$flags$ && (listeners.push(...hostCtx.li), hostCtx.$flags$ &= -3);\n        }\n        if (isHead && (flags |= 1), tagName in invisibleElements && (flags |= 16), tagName in textOnlyElements && (flags |= 8), \n        classStr && (openingElement += ' class=\"' + escapeAttr(classStr) + '\"'), listeners.length > 0) {\n            const groups = groupListeners(listeners);\n            const isInvisible = 0 != (16 & flags);\n            for (const listener of groups) {\n                const eventName = isInvisible ? normalizeInvisibleEvents(listener[0]) : listener[0];\n                openingElement += \" \" + eventName + '=\"' + serializeQRLs(listener[1], elCtx) + '\"', \n                registerQwikEvent$1(eventName, rCtx.$static$.$containerState$);\n            }\n        }\n        if (null != key && (openingElement += ' q:key=\"' + escapeAttr(key) + '\"'), hasRef || useSignal || listeners.length > 0) {\n            if (hasRef || useSignal || listenersNeedId(listeners)) {\n                const newID = getNextIndex(rCtx);\n                openingElement += ' q:id=\"' + newID + '\"', elCtx.$id$ = newID;\n            }\n            ssrCtx.$static$.$contexts$.push(elCtx);\n        }\n        if (1 & flags && (openingElement += \" q:head\"), openingElement += \">\", stream.write(openingElement), \n        tagName in emptyElements) {\n            return;\n        }\n        if (null != htmlStr) {\n            return stream.write(String(htmlStr)), void stream.write(`</${tagName}>`);\n        }\n        \"html\" === tagName ? flags |= 4 : flags &= -5, 2 & node.flags && (flags |= 1024);\n        const promise = processData$1(node.children, rCtx, ssrCtx, stream, flags);\n        return then(promise, (() => {\n            if (isHead) {\n                for (const node of ssrCtx.$static$.$headNodes$) {\n                    renderNodeElementSync(node.type, node.props, stream);\n                }\n                ssrCtx.$static$.$headNodes$.length = 0;\n            }\n            if (beforeClose) {\n                return then(beforeClose(stream), (() => {\n                    stream.write(`</${tagName}>`);\n                }));\n            }\n            stream.write(`</${tagName}>`);\n        }));\n    }\n    if (tagName === Virtual) {\n        const elCtx = createSSRContext(111);\n        return elCtx.$parent$ = rCtx.$cmpCtx$, elCtx.$slotParent$ = rCtx.$slotCtx$, hostCtx && 8 & hostCtx.$flags$ && addDynamicSlot(hostCtx, elCtx), \n        renderNodeVirtual(node, elCtx, void 0, rCtx, ssrCtx, stream, flags, beforeClose);\n    }\n    if (tagName === SSRRaw) {\n        return void stream.write(node.props.data);\n    }\n    if (tagName === InternalSSRStream) {\n        return renderGenerator(node, rCtx, ssrCtx, stream, flags);\n    }\n    const res = invoke(ssrCtx.$invocationContext$, tagName, node.props, node.key, node.flags, node.dev);\n    return shouldWrapFunctional(res, node) ? renderNode(_jsxC(Virtual, {\n        children: res\n    }, 0, node.key), rCtx, ssrCtx, stream, flags, beforeClose) : processData$1(res, rCtx, ssrCtx, stream, flags, beforeClose);\n};\n\nconst processData$1 = (node, rCtx, ssrCtx, stream, flags, beforeClose) => {\n    if (null != node && \"boolean\" != typeof node) {\n        if (!isString(node) && \"number\" != typeof node) {\n            if (isJSXNode(node)) {\n                return renderNode(node, rCtx, ssrCtx, stream, flags, beforeClose);\n            }\n            if (isArray(node)) {\n                return walkChildren(node, rCtx, ssrCtx, stream, flags);\n            }\n            if (isSignal(node)) {\n                const insideText = 8 & flags;\n                const hostEl = rCtx.$cmpCtx$?.$element$;\n                let value;\n                if (hostEl) {\n                    if (!insideText) {\n                        const id = getNextIndex(rCtx);\n                        value = trackSignal(node, 1024 & flags ? [ 3, \"#\" + id, node, \"#\" + id ] : [ 4, hostEl, node, \"#\" + id ]);\n                        const str = jsxToString(value);\n                        return ssrCtx.$static$.$textNodes$.set(str, id), void stream.write(`\\x3c!--t=${id}--\\x3e${escapeHtml(str)}\\x3c!----\\x3e`);\n                    }\n                    value = invoke(ssrCtx.$invocationContext$, (() => node.value));\n                }\n                return void stream.write(escapeHtml(jsxToString(value)));\n            }\n            return isPromise(node) ? (stream.write(FLUSH_COMMENT), node.then((node => processData$1(node, rCtx, ssrCtx, stream, flags, beforeClose)))) : void logWarn(\"A unsupported value was passed to the JSX, skipping render. Value:\", node);\n        }\n        stream.write(escapeHtml(String(node)));\n    }\n};\n\nconst walkChildren = (children, rCtx, ssrContext, stream, flags) => {\n    if (null == children) {\n        return;\n    }\n    if (!isArray(children)) {\n        return processData$1(children, rCtx, ssrContext, stream, flags);\n    }\n    const len = children.length;\n    if (1 === len) {\n        return processData$1(children[0], rCtx, ssrContext, stream, flags);\n    }\n    if (0 === len) {\n        return;\n    }\n    let currentIndex = 0;\n    const buffers = [];\n    return children.reduce(((prevPromise, child, index) => {\n        const buffer = [];\n        buffers.push(buffer);\n        const rendered = processData$1(child, rCtx, ssrContext, prevPromise ? {\n            write(chunk) {\n                currentIndex === index ? stream.write(chunk) : buffer.push(chunk);\n            }\n        } : stream, flags);\n        const next = () => {\n            currentIndex++, buffers.length > currentIndex && buffers[currentIndex].forEach((chunk => stream.write(chunk)));\n        };\n        return isPromise(rendered) && prevPromise ? Promise.all([ rendered, prevPromise ]).then(next) : isPromise(rendered) ? rendered.then(next) : prevPromise ? prevPromise.then(next) : void currentIndex++;\n    }), void 0);\n};\n\nconst flatVirtualChildren = (children, ssrCtx) => {\n    if (null == children) {\n        return null;\n    }\n    const result = _flatVirtualChildren(children, ssrCtx);\n    const nodes = isArray(result) ? result : [ result ];\n    return 0 === nodes.length ? null : nodes;\n};\n\nconst _flatVirtualChildren = (children, ssrCtx) => {\n    if (null == children) {\n        return null;\n    }\n    if (isArray(children)) {\n        return children.flatMap((c => _flatVirtualChildren(c, ssrCtx)));\n    }\n    if (isJSXNode(children) && isFunction(children.type) && children.type !== SSRRaw && children.type !== InternalSSRStream && children.type !== Virtual) {\n        const res = invoke(ssrCtx.$invocationContext$, children.type, children.props, children.key, children.flags);\n        return flatVirtualChildren(res, ssrCtx);\n    }\n    return children;\n};\n\nconst setComponentProps$1 = (rCtx, elCtx, expectProps) => {\n    const keys = Object.keys(expectProps);\n    const target = createPropsState();\n    if (elCtx.$props$ = createProxy(target, rCtx.$static$.$containerState$), 0 === keys.length) {\n        return;\n    }\n    const immutableMeta = target[_IMMUTABLE] = expectProps[_IMMUTABLE] ?? EMPTY_OBJ;\n    for (const prop of keys) {\n        \"children\" !== prop && prop !== QSlot && (isSignal(immutableMeta[prop]) ? target[\"$$\" + prop] = immutableMeta[prop] : target[prop] = expectProps[prop]);\n    }\n};\n\nconst processPropKey = prop => \"htmlFor\" === prop ? \"for\" : prop;\n\nconst processPropValue = (prop, value) => \"class\" === prop ? serializeClass(value) : \"style\" === prop ? stringifyStyle(value) : isAriaAttribute(prop) || \"draggable\" === prop || \"spellcheck\" === prop ? null != value ? String(value) : value : !1 === value || null == value ? null : !0 === value ? \"\" : String(value);\n\nconst invisibleElements = {\n    head: !0,\n    style: !0,\n    script: !0,\n    link: !0,\n    meta: !0\n};\n\nconst textOnlyElements = {\n    title: !0,\n    style: !0,\n    script: !0,\n    noframes: !0,\n    textarea: !0\n};\n\nconst emptyElements = {\n    area: !0,\n    base: !0,\n    basefont: !0,\n    bgsound: !0,\n    br: !0,\n    col: !0,\n    embed: !0,\n    frame: !0,\n    hr: !0,\n    img: !0,\n    input: !0,\n    keygen: !0,\n    link: !0,\n    meta: !0,\n    param: !0,\n    source: !0,\n    track: !0,\n    wbr: !0\n};\n\nconst startPhasingContent = {\n    p: !0,\n    pre: !0\n};\n\nconst htmlContent = {\n    head: !0,\n    body: !0\n};\n\nconst tableContent = {\n    tbody: !0,\n    thead: !0,\n    tfoot: !0,\n    caption: !0,\n    colgroup: !0\n};\n\nconst headContent = {\n    meta: !0,\n    title: !0,\n    link: !0,\n    style: !0,\n    script: !0,\n    noscript: !0,\n    template: !0,\n    base: !0\n};\n\nconst phasingContent = {\n    a: !0,\n    abbr: !0,\n    area: !0,\n    audio: !0,\n    b: !0,\n    bdi: !0,\n    bdo: !0,\n    br: !0,\n    button: !0,\n    canvas: !0,\n    cite: !0,\n    code: !0,\n    command: !0,\n    data: !0,\n    datalist: !0,\n    del: !0,\n    dfn: !0,\n    em: !0,\n    embed: !0,\n    i: !0,\n    iframe: !0,\n    img: !0,\n    input: !0,\n    ins: !0,\n    itemprop: !0,\n    kbd: !0,\n    keygen: !0,\n    label: !0,\n    link: !0,\n    map: !0,\n    mark: !0,\n    math: !0,\n    meta: !0,\n    meter: !0,\n    noscript: !0,\n    object: !0,\n    option: !0,\n    output: !0,\n    picture: !0,\n    progress: !0,\n    q: !0,\n    ruby: !0,\n    s: !0,\n    samp: !0,\n    script: !0,\n    select: !0,\n    slot: !0,\n    small: !0,\n    span: !0,\n    strong: !0,\n    sub: !0,\n    sup: !0,\n    svg: !0,\n    template: !0,\n    textarea: !0,\n    time: !0,\n    u: !0,\n    var: !0,\n    video: !0,\n    wbr: !0\n};\n\nconst ESCAPE_HTML = /[&<>]/g;\n\nconst ESCAPE_ATTRIBUTES = /[&\"]/g;\n\nconst registerQwikEvent$1 = (prop, containerState) => {\n    containerState.$events$.add(getEventName(prop));\n};\n\nconst escapeHtml = s => s.replace(ESCAPE_HTML, (c => {\n    switch (c) {\n      case \"&\":\n        return \"&amp;\";\n\n      case \"<\":\n        return \"&lt;\";\n\n      case \">\":\n        return \"&gt;\";\n\n      default:\n        return \"\";\n    }\n}));\n\nconst escapeAttr = s => s.replace(ESCAPE_ATTRIBUTES, (c => {\n    switch (c) {\n      case \"&\":\n        return \"&amp;\";\n\n      case '\"':\n        return \"&quot;\";\n\n      default:\n        return \"\";\n    }\n}));\n\nconst unsafeAttrCharRE = /[>/=\"'\\u0009\\u000a\\u000c\\u0020]/;\n\nconst isSSRUnsafeAttr = name => unsafeAttrCharRE.test(name);\n\nconst listenersNeedId = listeners => listeners.some((l => l[1].$captureRef$ && l[1].$captureRef$.length > 0));\n\nconst addDynamicSlot = (hostCtx, elCtx) => {\n    let dynamicSlots = hostCtx.$dynamicSlots$;\n    dynamicSlots || (hostCtx.$dynamicSlots$ = dynamicSlots = []), dynamicSlots.includes(elCtx) || dynamicSlots.push(elCtx);\n};\n\nconst normalizeInvisibleEvents = eventName => \"on:qvisible\" === eventName ? \"on-document:qinit\" : eventName;\n\nconst emitEvent$1 = (el, eventName, detail, bubbles) => {\n    (isBrowser || \"function\" == typeof CustomEvent) && el && el.dispatchEvent(new CustomEvent(eventName, {\n        detail,\n        bubbles,\n        composed: bubbles\n    }));\n};\n\nconst renderComponent = (rCtx, elCtx, flags) => {\n    const justMounted = !(4 & elCtx.$flags$);\n    const hostElement = elCtx.$element$;\n    const containerState = rCtx.$static$.$containerState$;\n    return containerState.$hostsStaging$.delete(elCtx), containerState.$subsManager$.$clearSub$(hostElement), \n    then(executeComponent(rCtx, elCtx), (res => {\n        const staticCtx = rCtx.$static$;\n        const newCtx = res.rCtx;\n        const iCtx = newInvokeContext(rCtx.$static$.$locale$, hostElement);\n        if (staticCtx.$hostElements$.add(hostElement), iCtx.$subscriber$ = [ 0, hostElement ], \n        iCtx.$renderCtx$ = newCtx, justMounted && elCtx.$appendStyles$) {\n            for (const style of elCtx.$appendStyles$) {\n                appendHeadStyle(staticCtx, style);\n            }\n        }\n        const processedJSXNode = processData(res.node, iCtx);\n        return then(processedJSXNode, (processedJSXNode => {\n            const newVdom = wrapJSX(hostElement, processedJSXNode);\n            const oldVdom = getVdom(elCtx);\n            return then(smartUpdateChildren(newCtx, oldVdom, newVdom, flags), (() => {\n                elCtx.$vdom$ = newVdom;\n            }));\n        }));\n    }));\n};\n\nconst getVdom = elCtx => (elCtx.$vdom$ || (elCtx.$vdom$ = domToVnode(elCtx.$element$)), \nelCtx.$vdom$);\n\nclass ProcessedJSXNodeImpl {\n    constructor($type$, $props$, $immutableProps$, $children$, $flags$, $key$) {\n        this.$type$ = $type$, this.$props$ = $props$, this.$immutableProps$ = $immutableProps$, \n        this.$children$ = $children$, this.$flags$ = $flags$, this.$key$ = $key$, this.$elm$ = null, \n        this.$text$ = \"\", this.$signal$ = null, this.$id$ = $type$ + ($key$ ? \":\" + $key$ : \"\"), \n        seal();\n    }\n}\n\nconst processNode = (node, invocationContext) => {\n    const {key, type, props, children, flags, immutableProps} = node;\n    let textType = \"\";\n    if (isString(type)) {\n        textType = type;\n    } else {\n        if (type !== Virtual) {\n            if (isFunction(type)) {\n                const res = invoke(invocationContext, type, props, key, flags, node.dev);\n                return shouldWrapFunctional(res, node) ? processNode(_jsxC(Virtual, {\n                    children: res\n                }, 0, key), invocationContext) : processData(res, invocationContext);\n            }\n            throw qError(25, type);\n        }\n        textType = VIRTUAL;\n    }\n    let convertedChildren = EMPTY_ARRAY;\n    if (null != children) {\n        return then(processData(children, invocationContext), (result => {\n            void 0 !== result && (convertedChildren = isArray(result) ? result : [ result ]);\n            const vnode = new ProcessedJSXNodeImpl(textType, props, immutableProps, convertedChildren, flags, key);\n            return vnode;\n        }));\n    }\n    {\n        const vnode = new ProcessedJSXNodeImpl(textType, props, immutableProps, convertedChildren, flags, key);\n        return vnode;\n    }\n};\n\nconst wrapJSX = (element, input) => {\n    const children = void 0 === input ? EMPTY_ARRAY : isArray(input) ? input : [ input ];\n    const node = new ProcessedJSXNodeImpl(\":virtual\", {}, null, children, 0, null);\n    return node.$elm$ = element, node;\n};\n\nconst processData = (node, invocationContext) => {\n    if (null != node && \"boolean\" != typeof node) {\n        if (isPrimitive(node)) {\n            const newNode = new ProcessedJSXNodeImpl(\"#text\", EMPTY_OBJ, null, EMPTY_ARRAY, 0, null);\n            return newNode.$text$ = String(node), newNode;\n        }\n        if (isJSXNode(node)) {\n            return processNode(node, invocationContext);\n        }\n        if (isSignal(node)) {\n            const newNode = new ProcessedJSXNodeImpl(\"#text\", EMPTY_OBJ, null, EMPTY_ARRAY, 0, null);\n            return newNode.$signal$ = node, newNode;\n        }\n        if (isArray(node)) {\n            const output = promiseAll(node.flatMap((n => processData(n, invocationContext))));\n            return then(output, (array => array.flat(100).filter(isNotNullable)));\n        }\n        return isPromise(node) ? node.then((node => processData(node, invocationContext))) : node === SkipRender ? new ProcessedJSXNodeImpl(SKIP_RENDER_TYPE, EMPTY_OBJ, null, EMPTY_ARRAY, 0, null) : void logWarn(\"A unsupported value was passed to the JSX, skipping render. Value:\", node);\n    }\n};\n\nconst isPrimitive = obj => isString(obj) || \"number\" == typeof obj;\n\nconst resumeIfNeeded = containerEl => {\n    \"paused\" === directGetAttribute(containerEl, \"q:container\") && (resumeContainer(containerEl), \n    appendQwikDevTools(containerEl));\n};\n\nconst getPauseState = containerEl => {\n    const doc = getDocument(containerEl);\n    const script = getQwikJSON(containerEl === doc.documentElement ? doc.body : containerEl, \"type\");\n    if (script) {\n        return JSON.parse(unescapeText(script.firstChild.data) || \"{}\");\n    }\n};\n\nconst _deserializeData = (data, element) => {\n    const obj = JSON.parse(data);\n    if (\"object\" != typeof obj) {\n        return null;\n    }\n    const {_objs, _entry} = obj;\n    if (void 0 === _objs || void 0 === _entry) {\n        return null;\n    }\n    let doc = {};\n    let containerState = {};\n    if (isNode$1(element) && isQwikElement(element)) {\n        const containerEl = getWrappingContainer(element);\n        containerEl && (containerState = _getContainerState(containerEl), doc = containerEl.ownerDocument);\n    }\n    const parser = createParser(containerState, doc);\n    for (let i = 0; i < _objs.length; i++) {\n        const value = _objs[i];\n        isString(value) && (_objs[i] = value === UNDEFINED_PREFIX ? void 0 : parser.prepare(value));\n    }\n    const getObject = id => _objs[strToInt(id)];\n    for (const obj of _objs) {\n        reviveNestedObjects(obj, getObject, parser);\n    }\n    return getObject(_entry);\n};\n\nconst resumeContainer = containerEl => {\n    if (!isElement$1(el = containerEl) || !el.hasAttribute(\"q:container\")) {\n        return void logWarn(\"Skipping hydration because parent element is not q:container\");\n    }\n    var el;\n    const pauseState = containerEl._qwikjson_ ?? getPauseState(containerEl);\n    if (containerEl._qwikjson_ = null, !pauseState) {\n        return void logWarn(\"Skipping hydration qwik/json metadata was not found.\");\n    }\n    const doc = getDocument(containerEl);\n    const parentJSON = containerEl === doc.documentElement ? doc.body : containerEl;\n    const inlinedFunctions = getQwikInlinedFuncs(parentJSON);\n    const containerState = _getContainerState(containerEl);\n    const elements = new Map;\n    const text = new Map;\n    let node = null;\n    let container = 0;\n    const elementWalker = doc.createTreeWalker(containerEl, 128);\n    for (;node = elementWalker.nextNode(); ) {\n        const data = node.data;\n        if (0 === container) {\n            if (data.startsWith(\"qv \")) {\n                const id = getID(data);\n                id >= 0 && elements.set(id, node);\n            } else if (data.startsWith(\"t=\")) {\n                const id = data.slice(2);\n                const index = strToInt(id);\n                const textNode = getTextNode(node);\n                elements.set(index, textNode), text.set(index, textNode.data);\n            }\n        }\n        \"cq\" === data ? container++ : \"/cq\" === data && container--;\n    }\n    const slotPath = 0 !== containerEl.getElementsByClassName(\"qc📦\").length;\n    containerEl.querySelectorAll(\"[q\\\\:id]\").forEach((el => {\n        if (slotPath && el.closest(\"[q\\\\:container]\") !== containerEl) {\n            return;\n        }\n        const id = directGetAttribute(el, \"q:id\");\n        assertDefined(id, \"resume: element missed q:id\", el);\n        const index = strToInt(id);\n        elements.set(index, el);\n    }));\n    const parser = createParser(containerState, doc);\n    const finalized = new Map;\n    const revived = new Set;\n    const getObject = id => (assertTrue(\"string\" == typeof id && id.length > 0, \"resume: id must be an non-empty string, got:\", id), \n    finalized.has(id) ? finalized.get(id) : computeObject(id));\n    const computeObject = id => {\n        if (id.startsWith(\"#\")) {\n            const elementId = id.slice(1);\n            const index = strToInt(elementId);\n            assertTrue(elements.has(index), \"missing element for id:\", elementId);\n            const rawElement = elements.get(index);\n            if (assertDefined(rawElement, \"missing element for id:\", elementId), isComment(rawElement)) {\n                if (!rawElement.isConnected) {\n                    return void finalized.set(id, void 0);\n                }\n                const close = findClose(rawElement);\n                const virtual = new VirtualElementImpl(rawElement, close, rawElement.parentElement?.namespaceURI === SVG_NS);\n                return finalized.set(id, virtual), getContext(virtual, containerState), virtual;\n            }\n            return isElement$1(rawElement) ? (finalized.set(id, rawElement), getContext(rawElement, containerState), \n            rawElement) : (finalized.set(id, rawElement), rawElement);\n        }\n        if (id.startsWith(\"@\")) {\n            const funcId = id.slice(1);\n            const index = strToInt(funcId);\n            const func = inlinedFunctions[index];\n            return assertDefined(func, \"missing inlined function for id:\", funcId), func;\n        }\n        if (id.startsWith(\"*\")) {\n            const elementId = id.slice(1);\n            const index = strToInt(elementId);\n            assertTrue(elements.has(index), \"missing element for id:\", elementId);\n            const str = text.get(index);\n            return assertDefined(str, \"missing element for id:\", elementId), finalized.set(id, str), \n            str;\n        }\n        const index = strToInt(id);\n        const objs = pauseState.objs;\n        assertTrue(objs.length > index, \"resume: index is out of bounds\", id);\n        let value = objs[index];\n        isString(value) && (value = value === UNDEFINED_PREFIX ? void 0 : parser.prepare(value));\n        let obj = value;\n        for (let i = id.length - 1; i >= 0; i--) {\n            const transform = OBJECT_TRANSFORMS[id[i]];\n            if (!transform) {\n                break;\n            }\n            obj = transform(obj, containerState);\n        }\n        return finalized.set(id, obj), isPrimitive(value) || revived.has(index) || (revived.add(index), \n        reviveSubscriptions(value, index, pauseState.subs, getObject, containerState, parser), \n        reviveNestedObjects(value, getObject, parser)), obj;\n    };\n    containerState.$elementIndex$ = 1e5, containerState.$pauseCtx$ = {\n        getObject,\n        meta: pauseState.ctx,\n        refs: pauseState.refs\n    }, directSetAttribute(containerEl, \"q:container\", \"resumed\"), logDebug(), emitEvent$1(containerEl, \"qresume\", void 0, !0);\n};\n\nconst reviveSubscriptions = (value, i, objsSubs, getObject, containerState, parser) => {\n    const subs = objsSubs[i];\n    if (subs) {\n        const converted = [];\n        let flag = 0;\n        for (const sub of subs) {\n            if (sub.startsWith(\"_\")) {\n                flag = parseInt(sub.slice(1), 10);\n            } else {\n                const parsed = parseSubscription(sub, getObject);\n                parsed && converted.push(parsed);\n            }\n        }\n        if (flag > 0 && setObjectFlags(value, flag), !parser.subs(value, converted)) {\n            const proxy = containerState.$proxyMap$.get(value);\n            proxy ? getSubscriptionManager(proxy).$addSubs$(converted) : createProxy(value, containerState, converted);\n        }\n    }\n};\n\nconst reviveNestedObjects = (obj, getObject, parser) => {\n    if (!parser.fill(obj, getObject) && obj && \"object\" == typeof obj) {\n        if (isArray(obj)) {\n            for (let i = 0; i < obj.length; i++) {\n                obj[i] = getObject(obj[i]);\n            }\n        } else if (isSerializableObject(obj)) {\n            for (const key in obj) {\n                obj[key] = getObject(obj[key]);\n            }\n        }\n    }\n};\n\nconst unescapeText = str => str.replace(/\\\\x3C(\\/?script)/g, \"<$1\");\n\nconst getQwikInlinedFuncs = parentElm => {\n    const elm = getQwikJSON(parentElm, \"q:func\");\n    return elm?.qFuncs ?? EMPTY_ARRAY;\n};\n\nconst getQwikJSON = (parentElm, attribute) => {\n    let child = parentElm.lastElementChild;\n    for (;child; ) {\n        if (\"SCRIPT\" === child.tagName && \"qwik/json\" === directGetAttribute(child, attribute)) {\n            return child;\n        }\n        child = child.previousElementSibling;\n    }\n};\n\nconst getTextNode = mark => {\n    const nextNode = mark.nextSibling;\n    if (isText(nextNode)) {\n        return nextNode;\n    }\n    {\n        const textNode = mark.ownerDocument.createTextNode(\"\");\n        return mark.parentElement.insertBefore(textNode, mark), textNode;\n    }\n};\n\nconst appendQwikDevTools = containerEl => {\n    containerEl.qwik = {\n        pause: () => pauseContainer(containerEl),\n        state: _getContainerState(containerEl)\n    };\n};\n\nconst getID = stuff => {\n    const index = stuff.indexOf(\"q:id=\");\n    return index > 0 ? strToInt(stuff.slice(index + 5)) : -1;\n};\n\nconst _jsxQ = (type, mutableProps, immutableProps, children, flags, key) => {\n    assertString(type, \"jsx type must be a string\");\n    const processed = null == key ? null : String(key);\n    const node = new JSXNodeImpl(type, mutableProps ?? EMPTY_OBJ, immutableProps, children, flags, processed);\n    return validateJSXNode(node), seal(), node;\n};\n\nconst _jsxS = (type, mutableProps, immutableProps, flags, key, dev) => {\n    let children = null;\n    return mutableProps && \"children\" in mutableProps && (children = mutableProps.children, \n    delete mutableProps.children), _jsxQ(type, mutableProps, immutableProps, children, flags, key, dev);\n};\n\nconst _jsxC = (type, mutableProps, flags, key) => {\n    const processed = null == key ? null : String(key);\n    const props = mutableProps ?? EMPTY_OBJ;\n    const node = new JSXNodeImpl(type, props, null, props.children, flags, processed);\n    return \"string\" == typeof type && mutableProps && delete mutableProps.children, \n    validateJSXNode(node), seal(), node;\n};\n\nconst jsx = (type, props, key) => {\n    const processed = null == key ? null : String(key);\n    const children = untrack((() => {\n        const c = props.children;\n        return \"string\" == typeof type && delete props.children, c;\n    }));\n    isString(type) && \"className\" in props && (props.class = props.className, delete props.className);\n    const node = new JSXNodeImpl(type, props, null, children, 0, processed);\n    return validateJSXNode(node), seal(), node;\n};\n\nconst SKIP_RENDER_TYPE = \":skipRender\";\n\nclass JSXNodeImpl {\n    constructor(type, props, immutableProps, children, flags, key = null) {\n        this.type = type, this.props = props, this.immutableProps = immutableProps, this.children = children, \n        this.flags = flags, this.key = key;\n    }\n}\n\nconst Virtual = props => props.children;\n\nconst RenderOnce = (props, key) => new JSXNodeImpl(Virtual, EMPTY_OBJ, null, props.children, 2, key);\n\nconst validateJSXNode = () => {\n    qDev;\n};\n\nconst printObjectLiteral = obj => `{ ${Object.keys(obj).map((key => `\"${key}\"`)).join(\", \")} }`;\n\nconst isJSXNode = n => n instanceof JSXNodeImpl;\n\nconst isValidJSXChild = node => !node || (node === SkipRender || (!(!isString(node) && \"number\" != typeof node && \"boolean\" != typeof node) || (!!isJSXNode(node) || (isArray(node) ? node.every(isValidJSXChild) : isSignal(node) ? isValidJSXChild(node.value) : !!isPromise(node)))));\n\nconst Fragment = props => props.children;\n\nconst HTMLFragment = props => jsx(Virtual, props);\n\nconst jsxDEV = (type, props, key, _isStatic, opts) => {\n    const processed = null == key ? null : String(key);\n    const children = untrack((() => {\n        const c = props.children;\n        return \"string\" == typeof type && delete props.children, c;\n    }));\n    isString(type) && \"className\" in props && (props.class = props.className, delete props.className);\n    const node = new JSXNodeImpl(type, props, null, children, 0, processed);\n    return node.dev = {\n        stack: (new Error).stack,\n        ...opts\n    }, validateJSXNode(node), seal(), node;\n};\n\nconst createJSXError = (message, node) => {\n    const error = new Error(message);\n    return node.dev ? (error.stack = `JSXError: ${message}\\n${filterStack(node.dev.stack, 1)}`, \n    error) : error;\n};\n\nconst filterStack = (stack, offset = 0) => stack.split(\"\\n\").slice(offset).join(\"\\n\");\n\nconst SVG_NS = \"http://www.w3.org/2000/svg\";\n\nconst IS_SVG = 1;\n\nconst IS_HEAD = 2;\n\nconst IS_IMMUTABLE = 4;\n\nconst CHILDREN_PLACEHOLDER = [];\n\nconst smartUpdateChildren = (ctx, oldVnode, newVnode, flags) => {\n    assertQwikElement(oldVnode.$elm$);\n    const ch = newVnode.$children$;\n    if (1 === ch.length && ch[0].$type$ === SKIP_RENDER_TYPE) {\n        return void (newVnode.$children$ = oldVnode.$children$);\n    }\n    const elm = oldVnode.$elm$;\n    let filter = isChildComponent;\n    if (oldVnode.$children$ === CHILDREN_PLACEHOLDER) {\n        \"HEAD\" === elm.nodeName && (filter = isHeadChildren, flags |= 2);\n    }\n    const oldCh = getVnodeChildren(oldVnode, filter);\n    return oldCh.length > 0 && ch.length > 0 ? diffChildren(ctx, elm, oldCh, ch, flags) : oldCh.length > 0 && 0 === ch.length ? removeChildren(ctx.$static$, oldCh, 0, oldCh.length - 1) : ch.length > 0 ? addChildren(ctx, elm, null, ch, 0, ch.length - 1, flags) : void 0;\n};\n\nconst getVnodeChildren = (oldVnode, filter) => {\n    const oldCh = oldVnode.$children$;\n    return oldCh === CHILDREN_PLACEHOLDER ? oldVnode.$children$ = getChildrenVnodes(oldVnode.$elm$, filter) : oldCh;\n};\n\nconst diffChildren = (ctx, parentElm, oldCh, newCh, flags) => {\n    let oldStartIdx = 0;\n    let newStartIdx = 0;\n    let oldEndIdx = oldCh.length - 1;\n    let oldStartVnode = oldCh[0];\n    let oldEndVnode = oldCh[oldEndIdx];\n    let newEndIdx = newCh.length - 1;\n    let newStartVnode = newCh[0];\n    let newEndVnode = newCh[newEndIdx];\n    let oldKeyToIdx;\n    let idxInOld;\n    let elmToMove;\n    const results = [];\n    const staticCtx = ctx.$static$;\n    for (;oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx; ) {\n        if (null == oldStartVnode) {\n            oldStartVnode = oldCh[++oldStartIdx];\n        } else if (null == oldEndVnode) {\n            oldEndVnode = oldCh[--oldEndIdx];\n        } else if (null == newStartVnode) {\n            newStartVnode = newCh[++newStartIdx];\n        } else if (null == newEndVnode) {\n            newEndVnode = newCh[--newEndIdx];\n        } else if (oldStartVnode.$id$ === newStartVnode.$id$) {\n            results.push(diffVnode(ctx, oldStartVnode, newStartVnode, flags)), oldStartVnode = oldCh[++oldStartIdx], \n            newStartVnode = newCh[++newStartIdx];\n        } else if (oldEndVnode.$id$ === newEndVnode.$id$) {\n            results.push(diffVnode(ctx, oldEndVnode, newEndVnode, flags)), oldEndVnode = oldCh[--oldEndIdx], \n            newEndVnode = newCh[--newEndIdx];\n        } else if (oldStartVnode.$key$ && oldStartVnode.$id$ === newEndVnode.$id$) {\n            assertDefined(oldStartVnode.$elm$, \"oldStartVnode $elm$ must be defined\"), assertDefined(oldEndVnode.$elm$, \"oldEndVnode $elm$ must be defined\"), \n            results.push(diffVnode(ctx, oldStartVnode, newEndVnode, flags)), insertAfter(staticCtx, parentElm, oldStartVnode.$elm$, oldEndVnode.$elm$), \n            oldStartVnode = oldCh[++oldStartIdx], newEndVnode = newCh[--newEndIdx];\n        } else if (oldEndVnode.$key$ && oldEndVnode.$id$ === newStartVnode.$id$) {\n            assertDefined(oldStartVnode.$elm$, \"oldStartVnode $elm$ must be defined\"), assertDefined(oldEndVnode.$elm$, \"oldEndVnode $elm$ must be defined\"), \n            results.push(diffVnode(ctx, oldEndVnode, newStartVnode, flags)), insertBefore(staticCtx, parentElm, oldEndVnode.$elm$, oldStartVnode.$elm$), \n            oldEndVnode = oldCh[--oldEndIdx], newStartVnode = newCh[++newStartIdx];\n        } else {\n            if (void 0 === oldKeyToIdx && (oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)), \n            idxInOld = oldKeyToIdx[newStartVnode.$key$], void 0 === idxInOld) {\n                const newElm = createElm(ctx, newStartVnode, flags, results);\n                insertBefore(staticCtx, parentElm, newElm, oldStartVnode?.$elm$);\n            } else if (elmToMove = oldCh[idxInOld], elmToMove.$type$ !== newStartVnode.$type$) {\n                const newElm = createElm(ctx, newStartVnode, flags, results);\n                then(newElm, (newElm => {\n                    insertBefore(staticCtx, parentElm, newElm, oldStartVnode?.$elm$);\n                }));\n            } else {\n                results.push(diffVnode(ctx, elmToMove, newStartVnode, flags)), oldCh[idxInOld] = void 0, \n                assertDefined(elmToMove.$elm$, \"elmToMove $elm$ must be defined\"), insertBefore(staticCtx, parentElm, elmToMove.$elm$, oldStartVnode.$elm$);\n            }\n            newStartVnode = newCh[++newStartIdx];\n        }\n    }\n    if (newStartIdx <= newEndIdx) {\n        results.push(addChildren(ctx, parentElm, null == newCh[newEndIdx + 1] ? null : newCh[newEndIdx + 1].$elm$, newCh, newStartIdx, newEndIdx, flags));\n    }\n    let wait = promiseAll(results);\n    return oldStartIdx <= oldEndIdx && (wait = then(wait, (() => {\n        removeChildren(staticCtx, oldCh, oldStartIdx, oldEndIdx);\n    }))), wait;\n};\n\nconst getChildren = (elm, filter) => {\n    const end = isVirtualElement(elm) ? elm.close : null;\n    const nodes = [];\n    let node = elm.firstChild;\n    for (;(node = processVirtualNodes(node)) && (filter(node) && nodes.push(node), node = node.nextSibling, \n    node !== end); ) {}\n    return nodes;\n};\n\nconst getChildrenVnodes = (elm, filter) => getChildren(elm, filter).map(getVnodeFromEl);\n\nconst getVnodeFromEl = el => isElement$1(el) ? tryGetContext(el)?.$vdom$ ?? domToVnode(el) : domToVnode(el);\n\nconst domToVnode = node => {\n    if (isQwikElement(node)) {\n        const t = new ProcessedJSXNodeImpl(node.localName, {}, null, CHILDREN_PLACEHOLDER, 0, getKey(node));\n        return t.$elm$ = node, t;\n    }\n    if (isText(node)) {\n        const t = new ProcessedJSXNodeImpl(node.nodeName, EMPTY_OBJ, null, CHILDREN_PLACEHOLDER, 0, null);\n        return t.$text$ = node.data, t.$elm$ = node, t;\n    }\n    assertFail(\"Invalid node type\");\n};\n\nconst isHeadChildren = node => {\n    const type = node.nodeType;\n    return 1 === type ? node.hasAttribute(\"q:head\") : 111 === type;\n};\n\nconst isSlotTemplate = node => \"Q:TEMPLATE\" === node.nodeName;\n\nconst isChildComponent = node => {\n    const type = node.nodeType;\n    if (3 === type || 111 === type) {\n        return !0;\n    }\n    if (1 !== type) {\n        return !1;\n    }\n    const nodeName = node.nodeName;\n    return \"Q:TEMPLATE\" !== nodeName && (\"HEAD\" === nodeName ? node.hasAttribute(\"q:head\") : \"STYLE\" !== nodeName || !node.hasAttribute(QStyle));\n};\n\nconst splitChildren = input => {\n    const output = {};\n    for (const item of input) {\n        const key = getSlotName(item);\n        (output[key] ?? (output[key] = new ProcessedJSXNodeImpl(VIRTUAL, {\n            \"q:s\": \"\"\n        }, null, [], 0, key))).$children$.push(item);\n    }\n    return output;\n};\n\nconst diffVnode = (rCtx, oldVnode, newVnode, flags) => {\n    assertEqual(oldVnode.$type$, newVnode.$type$, \"old and new vnodes type must be the same\"), \n    assertEqual(oldVnode.$key$, newVnode.$key$, \"old and new vnodes key must be the same\"), \n    assertEqual(oldVnode.$id$, newVnode.$id$, \"old and new vnodes key must be the same\");\n    const elm = oldVnode.$elm$;\n    const tag = newVnode.$type$;\n    const staticCtx = rCtx.$static$;\n    const containerState = staticCtx.$containerState$;\n    const currentComponent = rCtx.$cmpCtx$;\n    if (assertDefined(elm, \"while patching element must be defined\"), assertDefined(currentComponent, \"while patching current component must be defined\"), \n    newVnode.$elm$ = elm, \"#text\" === tag) {\n        staticCtx.$visited$.push(elm);\n        const signal = newVnode.$signal$;\n        return signal && (newVnode.$text$ = jsxToString(trackSignal(signal, [ 4, currentComponent.$element$, signal, elm ]))), \n        void setProperty(staticCtx, elm, \"data\", newVnode.$text$);\n    }\n    assertQwikElement(elm);\n    const props = newVnode.$props$;\n    const vnodeFlags = newVnode.$flags$;\n    const elCtx = getContext(elm, containerState);\n    if (tag !== VIRTUAL) {\n        let isSvg = 0 != (1 & flags);\n        if (isSvg || \"svg\" !== tag || (flags |= 1, isSvg = !0), props !== EMPTY_OBJ) {\n            0 == (1 & vnodeFlags) && (elCtx.li.length = 0);\n            const values = oldVnode.$props$;\n            newVnode.$props$ = values;\n            for (const prop in props) {\n                let newValue = props[prop];\n                if (\"ref\" !== prop) {\n                    if (isOnProp(prop)) {\n                        const normalized = setEvent(elCtx.li, prop, newValue, containerState.$containerEl$);\n                        addQwikEvent(staticCtx, elm, normalized);\n                    } else {\n                        isSignal(newValue) && (newValue = trackSignal(newValue, [ 1, currentComponent.$element$, newValue, elm, prop ])), \n                        \"class\" === prop ? newValue = serializeClassWithHost(newValue, currentComponent) : \"style\" === prop && (newValue = stringifyStyle(newValue)), \n                        values[prop] !== newValue && (values[prop] = newValue, smartSetProperty(staticCtx, elm, prop, newValue, isSvg));\n                    }\n                } else {\n                    assertElement(elm), void 0 !== newValue && setRef(newValue, elm);\n                }\n            }\n        }\n        if (2 & vnodeFlags) {\n            return;\n        }\n        isSvg && \"foreignObject\" === tag && (flags &= -2);\n        if (void 0 !== props[dangerouslySetInnerHTML]) {\n            return void 0;\n        }\n        if (\"textarea\" === tag) {\n            return;\n        }\n        return smartUpdateChildren(rCtx, oldVnode, newVnode, flags);\n    }\n    if (\"q:renderFn\" in props) {\n        const cmpProps = props.props;\n        setComponentProps(containerState, elCtx, cmpProps);\n        let needsRender = !!(1 & elCtx.$flags$);\n        return needsRender || elCtx.$componentQrl$ || elCtx.$element$.hasAttribute(\"q:id\") || (setQId(rCtx, elCtx), \n        elCtx.$componentQrl$ = cmpProps[\"q:renderFn\"], assertQrl(elCtx.$componentQrl$), \n        needsRender = !0), needsRender ? then(renderComponent(rCtx, elCtx, flags), (() => renderContentProjection(rCtx, elCtx, newVnode, flags))) : renderContentProjection(rCtx, elCtx, newVnode, flags);\n    }\n    if (\"q:s\" in props) {\n        return assertDefined(currentComponent.$slots$, \"current component slots must be a defined array\"), \n        void currentComponent.$slots$.push(newVnode);\n    }\n    if (dangerouslySetInnerHTML in props) {\n        setProperty(staticCtx, elm, \"innerHTML\", props[dangerouslySetInnerHTML]);\n    } else if (!(2 & vnodeFlags)) {\n        return smartUpdateChildren(rCtx, oldVnode, newVnode, flags);\n    }\n};\n\nconst renderContentProjection = (rCtx, hostCtx, vnode, flags) => {\n    if (2 & vnode.$flags$) {\n        return;\n    }\n    const staticCtx = rCtx.$static$;\n    const splittedNewChildren = splitChildren(vnode.$children$);\n    const slotMaps = getSlotMap(hostCtx);\n    for (const key in slotMaps.slots) {\n        if (!splittedNewChildren[key]) {\n            const slotEl = slotMaps.slots[key];\n            const oldCh = getChildrenVnodes(slotEl, isChildComponent);\n            if (oldCh.length > 0) {\n                const slotCtx = tryGetContext(slotEl);\n                slotCtx && slotCtx.$vdom$ && (slotCtx.$vdom$.$children$ = []), removeChildren(staticCtx, oldCh, 0, oldCh.length - 1);\n            }\n        }\n    }\n    for (const key in slotMaps.templates) {\n        const templateEl = slotMaps.templates[key];\n        templateEl && !splittedNewChildren[key] && (slotMaps.templates[key] = void 0, removeNode(staticCtx, templateEl));\n    }\n    return promiseAll(Object.keys(splittedNewChildren).map((slotName => {\n        const newVdom = splittedNewChildren[slotName];\n        const slotCtx = getSlotCtx(staticCtx, slotMaps, hostCtx, slotName, rCtx.$static$.$containerState$);\n        const oldVdom = getVdom(slotCtx);\n        const slotRctx = pushRenderContext(rCtx);\n        const slotEl = slotCtx.$element$;\n        slotRctx.$slotCtx$ = slotCtx, slotCtx.$vdom$ = newVdom, newVdom.$elm$ = slotEl;\n        let newFlags = -2 & flags;\n        slotEl.isSvg && (newFlags |= 1);\n        const index = staticCtx.$addSlots$.findIndex((slot => slot[0] === slotEl));\n        return index >= 0 && staticCtx.$addSlots$.splice(index, 1), smartUpdateChildren(slotRctx, oldVdom, newVdom, newFlags);\n    })));\n};\n\nconst addChildren = (ctx, parentElm, before, vnodes, startIdx, endIdx, flags) => {\n    const promises = [];\n    for (;startIdx <= endIdx; ++startIdx) {\n        const ch = vnodes[startIdx];\n        assertDefined(ch, \"render: node must be defined at index\", startIdx, vnodes);\n        const elm = createElm(ctx, ch, flags, promises);\n        insertBefore(ctx.$static$, parentElm, elm, before);\n    }\n    return promiseAllLazy(promises);\n};\n\nconst removeChildren = (staticCtx, nodes, startIdx, endIdx) => {\n    for (;startIdx <= endIdx; ++startIdx) {\n        const ch = nodes[startIdx];\n        ch && (assertDefined(ch.$elm$, \"vnode elm must be defined\"), removeNode(staticCtx, ch.$elm$));\n    }\n};\n\nconst getSlotCtx = (staticCtx, slotMaps, hostCtx, slotName, containerState) => {\n    const slotEl = slotMaps.slots[slotName];\n    if (slotEl) {\n        return getContext(slotEl, containerState);\n    }\n    const templateEl = slotMaps.templates[slotName];\n    if (templateEl) {\n        return getContext(templateEl, containerState);\n    }\n    const template = createTemplate(staticCtx.$doc$, slotName);\n    const elCtx = createContext(template);\n    return elCtx.$parent$ = hostCtx, prepend(staticCtx, hostCtx.$element$, template), \n    slotMaps.templates[slotName] = template, elCtx;\n};\n\nconst getSlotName = node => node.$props$[QSlot] ?? \"\";\n\nconst createElm = (rCtx, vnode, flags, promises) => {\n    const tag = vnode.$type$;\n    const doc = rCtx.$static$.$doc$;\n    const currentComponent = rCtx.$cmpCtx$;\n    if (\"#text\" === tag) {\n        const signal = vnode.$signal$;\n        const elm = doc.createTextNode(vnode.$text$);\n        if (signal) {\n            assertDefined(currentComponent, \"signals can not be used outside components\");\n            elm.data = vnode.$text$ = jsxToString(trackSignal(signal, 4 & flags ? [ 3, elm, signal, elm ] : [ 4, currentComponent.$element$, signal, elm ]));\n        }\n        return vnode.$elm$ = elm;\n    }\n    let elm;\n    let isSvg = !!(1 & flags);\n    isSvg || \"svg\" !== tag || (flags |= 1, isSvg = !0);\n    const isVirtual = tag === VIRTUAL;\n    const props = vnode.$props$;\n    const staticCtx = rCtx.$static$;\n    const containerState = staticCtx.$containerState$;\n    isVirtual ? elm = newVirtualElement(doc, isSvg) : \"head\" === tag ? (elm = doc.head, \n    flags |= 2) : (elm = createElement(doc, tag, isSvg), flags &= -3), 2 & vnode.$flags$ && (flags |= 4), \n    vnode.$elm$ = elm;\n    const elCtx = createContext(elm);\n    if (elCtx.$parent$ = rCtx.$cmpCtx$, elCtx.$slotParent$ = rCtx.$slotCtx$, isVirtual) {\n        if (\"q:renderFn\" in props) {\n            const renderQRL = props[\"q:renderFn\"];\n            assertQrl(renderQRL);\n            const target = createPropsState();\n            const manager = containerState.$subsManager$.$createManager$();\n            const proxy = new Proxy(target, new ReadWriteProxyHandler(containerState, manager));\n            const expectProps = props.props;\n            if (containerState.$proxyMap$.set(target, proxy), elCtx.$props$ = proxy, expectProps !== EMPTY_OBJ) {\n                const immutableMeta = target[_IMMUTABLE] = expectProps[_IMMUTABLE] ?? EMPTY_OBJ;\n                for (const prop in expectProps) {\n                    if (\"children\" !== prop && prop !== QSlot) {\n                        const immutableValue = immutableMeta[prop];\n                        isSignal(immutableValue) ? target[\"$$\" + prop] = immutableValue : target[prop] = expectProps[prop];\n                    }\n                }\n            }\n            setQId(rCtx, elCtx), elCtx.$componentQrl$ = renderQRL;\n            const wait = then(renderComponent(rCtx, elCtx, flags), (() => {\n                let children = vnode.$children$;\n                if (0 === children.length) {\n                    return;\n                }\n                1 === children.length && children[0].$type$ === SKIP_RENDER_TYPE && (children = children[0].$children$);\n                const slotMap = getSlotMap(elCtx);\n                const p = [];\n                const splittedNewChildren = splitChildren(children);\n                for (const slotName in splittedNewChildren) {\n                    const newVnode = splittedNewChildren[slotName];\n                    const slotCtx = getSlotCtx(staticCtx, slotMap, elCtx, slotName, staticCtx.$containerState$);\n                    const slotRctx = pushRenderContext(rCtx);\n                    const slotEl = slotCtx.$element$;\n                    slotRctx.$slotCtx$ = slotCtx, slotCtx.$vdom$ = newVnode, newVnode.$elm$ = slotEl;\n                    let newFlags = -2 & flags;\n                    slotEl.isSvg && (newFlags |= 1);\n                    for (const node of newVnode.$children$) {\n                        const nodeElm = createElm(slotRctx, node, newFlags, p);\n                        assertDefined(node.$elm$, \"vnode elm must be defined\"), assertEqual(nodeElm, node.$elm$, \"vnode elm must be defined\"), \n                        appendChild(staticCtx, slotEl, nodeElm);\n                    }\n                }\n                return promiseAllLazy(p);\n            }));\n            return isPromise(wait) && promises.push(wait), elm;\n        }\n        if (\"q:s\" in props) {\n            assertDefined(currentComponent, \"slot can only be used inside component\"), assertDefined(currentComponent.$slots$, \"current component slots must be a defined array\"), \n            el = elm, null !== (key = vnode.$key$) && directSetAttribute(el, \"q:key\", key), \n            directSetAttribute(elm, \"q:sref\", currentComponent.$id$), directSetAttribute(elm, \"q:s\", \"\"), \n            currentComponent.$slots$.push(vnode), staticCtx.$addSlots$.push([ elm, currentComponent.$element$ ]);\n        } else if (dangerouslySetInnerHTML in props) {\n            return setProperty(staticCtx, elm, \"innerHTML\", props[dangerouslySetInnerHTML]), \n            elm;\n        }\n    } else {\n        if (vnode.$immutableProps$ && setProperties(staticCtx, elCtx, currentComponent, vnode.$immutableProps$, isSvg, !0), \n        props !== EMPTY_OBJ && (elCtx.$vdom$ = vnode, vnode.$props$ = setProperties(staticCtx, elCtx, currentComponent, props, isSvg, !1)), \n        isSvg && \"foreignObject\" === tag && (isSvg = !1, flags &= -2), currentComponent) {\n            const scopedIds = currentComponent.$scopeIds$;\n            scopedIds && scopedIds.forEach((styleId => {\n                elm.classList.add(styleId);\n            })), 2 & currentComponent.$flags$ && (elCtx.li.push(...currentComponent.li), currentComponent.$flags$ &= -3);\n        }\n        for (const listener of elCtx.li) {\n            addQwikEvent(staticCtx, elm, listener[0]);\n        }\n        if (void 0 !== props[dangerouslySetInnerHTML]) {\n            return elm;\n        }\n        isSvg && \"foreignObject\" === tag && (isSvg = !1, flags &= -2);\n    }\n    var el, key;\n    let children = vnode.$children$;\n    if (0 === children.length) {\n        return elm;\n    }\n    1 === children.length && children[0].$type$ === SKIP_RENDER_TYPE && (children = children[0].$children$);\n    const nodes = children.map((ch => createElm(rCtx, ch, flags, promises)));\n    for (const node of nodes) {\n        directAppendChild(elm, node);\n    }\n    return elm;\n};\n\nconst getSlots = elCtx => {\n    const slots = elCtx.$slots$;\n    if (!slots) {\n        return assertDefined(elCtx.$element$.parentElement, \"component should be already attached to the dom\"), \n        elCtx.$slots$ = readDOMSlots(elCtx);\n    }\n    return slots;\n};\n\nconst getSlotMap = elCtx => {\n    const slotsArray = getSlots(elCtx);\n    const slots = {};\n    const templates = {};\n    const t = Array.from(elCtx.$element$.childNodes).filter(isSlotTemplate);\n    for (const vnode of slotsArray) {\n        assertQwikElement(vnode.$elm$), slots[vnode.$key$ ?? \"\"] = vnode.$elm$;\n    }\n    for (const elm of t) {\n        templates[directGetAttribute(elm, QSlot) ?? \"\"] = elm;\n    }\n    return {\n        slots,\n        templates\n    };\n};\n\nconst readDOMSlots = elCtx => {\n    const parent = elCtx.$element$.parentElement;\n    return assertDefined(parent, \"component should be already attached to the dom\"), \n    queryAllVirtualByAttribute(parent, \"q:sref\", elCtx.$id$).map(domToVnode);\n};\n\nconst handleStyle = (ctx, elm, newValue) => (setProperty(ctx, elm.style, \"cssText\", newValue), \n!0);\n\nconst handleClass = (ctx, elm, newValue) => (assertTrue(null == newValue || \"string\" == typeof newValue, \"class newValue must be either nullish or string\", newValue), \nelm.namespaceURI === SVG_NS ? setAttribute(ctx, elm, \"class\", newValue) : setProperty(ctx, elm, \"className\", newValue), \n!0);\n\nconst checkBeforeAssign = (ctx, elm, newValue, prop) => (prop in elm && elm[prop] !== newValue && (\"SELECT\" === elm.tagName ? ctx.$postOperations$.push({\n    $operation$: _setProperty,\n    $args$: [ elm, prop, newValue ]\n}) : setProperty(ctx, elm, prop, newValue)), !0);\n\nconst forceAttribute = (ctx, elm, newValue, prop) => (setAttribute(ctx, elm, prop.toLowerCase(), newValue), \n!0);\n\nconst setInnerHTML = (ctx, elm, newValue) => (setProperty(ctx, elm, \"innerHTML\", newValue), \n!0);\n\nconst noop = () => !0;\n\nconst PROP_HANDLER_MAP = {\n    style: handleStyle,\n    class: handleClass,\n    value: checkBeforeAssign,\n    checked: checkBeforeAssign,\n    href: forceAttribute,\n    list: forceAttribute,\n    form: forceAttribute,\n    tabIndex: forceAttribute,\n    download: forceAttribute,\n    innerHTML: noop,\n    [dangerouslySetInnerHTML]: setInnerHTML\n};\n\nconst smartSetProperty = (staticCtx, elm, prop, newValue, isSvg) => {\n    if (isAriaAttribute(prop)) {\n        return void setAttribute(staticCtx, elm, prop, null != newValue ? String(newValue) : newValue);\n    }\n    const exception = PROP_HANDLER_MAP[prop];\n    exception && exception(staticCtx, elm, newValue, prop) || (isSvg || !(prop in elm) ? (prop.startsWith(PREVENT_DEFAULT) && registerQwikEvent(prop.slice(15)), \n    setAttribute(staticCtx, elm, prop, newValue)) : setProperty(staticCtx, elm, prop, newValue));\n};\n\nconst setProperties = (staticCtx, elCtx, hostCtx, newProps, isSvg, immutable) => {\n    const values = {};\n    const elm = elCtx.$element$;\n    for (const prop in newProps) {\n        let newValue = newProps[prop];\n        if (\"ref\" !== prop) {\n            if (isOnProp(prop)) {\n                setEvent(elCtx.li, prop, newValue, staticCtx.$containerState$.$containerEl$);\n            } else {\n                if (isSignal(newValue) && (assertDefined(hostCtx, \"Signals can only be used in components\"), \n                newValue = trackSignal(newValue, immutable ? [ 1, elm, newValue, hostCtx.$element$, prop ] : [ 2, hostCtx.$element$, newValue, elm, prop ])), \n                \"class\" === prop) {\n                    if (newValue = serializeClassWithHost(newValue, hostCtx), !newValue) {\n                        continue;\n                    }\n                } else {\n                    \"style\" === prop && (newValue = stringifyStyle(newValue));\n                }\n                values[prop] = newValue, smartSetProperty(staticCtx, elm, prop, newValue, isSvg);\n            }\n        } else {\n            assertElement(elm), void 0 !== newValue && setRef(newValue, elm);\n        }\n    }\n    return values;\n};\n\nconst setComponentProps = (containerState, elCtx, expectProps) => {\n    let props = elCtx.$props$;\n    if (props || (elCtx.$props$ = props = createProxy(createPropsState(), containerState)), \n    expectProps === EMPTY_OBJ) {\n        return;\n    }\n    const manager = getSubscriptionManager(props);\n    assertDefined(manager, \"props have to be a proxy, but it is not\", props);\n    const target = getProxyTarget(props);\n    assertDefined(target, \"props have to be a proxy, but it is not\", props);\n    const immutableMeta = target[_IMMUTABLE] = expectProps[_IMMUTABLE] ?? EMPTY_OBJ;\n    for (const prop in expectProps) {\n        if (\"children\" !== prop && prop !== QSlot && !immutableMeta[prop]) {\n            const value = expectProps[prop];\n            target[prop] !== value && (target[prop] = value, manager.$notifySubs$(prop));\n        }\n    }\n};\n\nconst cleanupTree = (elm, staticCtx, subsManager, stopSlots) => {\n    if (subsManager.$clearSub$(elm), isQwikElement(elm)) {\n        if (stopSlots && elm.hasAttribute(\"q:s\")) {\n            return void staticCtx.$rmSlots$.push(elm);\n        }\n        const ctx = tryGetContext(elm);\n        ctx && cleanupContext(ctx, subsManager);\n        const end = isVirtualElement(elm) ? elm.close : null;\n        let node = elm.firstChild;\n        for (;(node = processVirtualNodes(node)) && (cleanupTree(node, staticCtx, subsManager, !0), \n        node = node.nextSibling, node !== end); ) {}\n    }\n};\n\nconst restoreScroll = () => {\n    document.__q_scroll_restore__ && (document.__q_scroll_restore__(), document.__q_scroll_restore__ = void 0);\n};\n\nconst executeContextWithScrollAndTransition = async ctx => {\n    isBrowser && document.__q_view_transition__ && (document.__q_view_transition__ = void 0, \n    document.startViewTransition) ? await document.startViewTransition((() => {\n        executeDOMRender(ctx), restoreScroll();\n    })).finished : (executeDOMRender(ctx), isBrowser && restoreScroll());\n};\n\nconst directAppendChild = (parent, child) => {\n    isVirtualElement(child) ? child.appendTo(parent) : parent.appendChild(child);\n};\n\nconst directRemoveChild = (parent, child) => {\n    isVirtualElement(child) ? child.remove() : parent.removeChild(child);\n};\n\nconst directInsertAfter = (parent, child, ref) => {\n    isVirtualElement(child) ? child.insertBeforeTo(parent, ref?.nextSibling ?? null) : parent.insertBefore(child, ref?.nextSibling ?? null);\n};\n\nconst directInsertBefore = (parent, child, ref) => {\n    isVirtualElement(child) ? child.insertBeforeTo(parent, getRootNode(ref)) : parent.insertBefore(child, getRootNode(ref));\n};\n\nconst createKeyToOldIdx = (children, beginIdx, endIdx) => {\n    const map = {};\n    for (let i = beginIdx; i <= endIdx; ++i) {\n        const key = children[i].$key$;\n        null != key && (map[key] = i);\n    }\n    return map;\n};\n\nconst addQwikEvent = (staticCtx, elm, prop) => {\n    prop.startsWith(\"on:\") || setAttribute(staticCtx, elm, prop, \"\"), registerQwikEvent(prop);\n};\n\nconst registerQwikEvent = prop => {\n    var _a;\n    {\n        const eventName = getEventName(prop);\n        try {\n            ((_a = globalThis).qwikevents || (_a.qwikevents = [])).push(eventName);\n        } catch (err) {\n            logWarn(err);\n        }\n    }\n};\n\nconst useLexicalScope = () => {\n    const context = getInvokeContext();\n    let qrl = context.$qrl$;\n    if (qrl) {\n        assertQrl(qrl), assertDefined(qrl.$captureRef$, \"invoke: qrl $captureRef$ must be defined inside useLexicalScope()\", qrl);\n    } else {\n        const el = context.$element$;\n        assertDefined(el, \"invoke: element must be defined inside useLexicalScope()\", context);\n        const container = getWrappingContainer(el);\n        assertDefined(container, \"invoke: cant find parent q:container of\", el), qrl = parseQRL(decodeURIComponent(String(context.$url$)), container), \n        assertQrl(qrl), resumeIfNeeded(container);\n        const elCtx = getContext(el, _getContainerState(container));\n        inflateQrl(qrl, elCtx);\n    }\n    return qrl.$captureRef$;\n};\n\nconst executeSignalOperation = (staticCtx, operation) => {\n    try {\n        const type = operation[0];\n        switch (type) {\n          case 1:\n          case 2:\n            {\n                let elm;\n                let hostElm;\n                1 === type ? (elm = operation[1], hostElm = operation[3]) : (elm = operation[3], \n                hostElm = operation[1]);\n                const elCtx = tryGetContext(elm);\n                if (null == elCtx) {\n                    return;\n                }\n                const prop = operation[4];\n                const isSVG = elm.namespaceURI === SVG_NS;\n                staticCtx.$containerState$.$subsManager$.$clearSignal$(operation);\n                let value = trackSignal(operation[2], operation.slice(0, -1));\n                \"class\" === prop ? value = serializeClassWithHost(value, tryGetContext(hostElm)) : \"style\" === prop && (value = stringifyStyle(value));\n                const vdom = getVdom(elCtx);\n                if (prop in vdom.$props$ && vdom.$props$[prop] === value) {\n                    return;\n                }\n                return vdom.$props$[prop] = value, smartSetProperty(staticCtx, elm, prop, value, isSVG);\n            }\n\n          case 3:\n          case 4:\n            {\n                const elm = operation[3];\n                if (!staticCtx.$visited$.includes(elm)) {\n                    staticCtx.$containerState$.$subsManager$.$clearSignal$(operation);\n                    const value = trackSignal(operation[2], operation.slice(0, -1));\n                    return setProperty(staticCtx, elm, \"data\", jsxToString(value));\n                }\n            }\n        }\n    } catch (e) {}\n};\n\nconst notifyChange = (subAction, containerState) => {\n    if (0 === subAction[0]) {\n        const host = subAction[1];\n        isSubscriberDescriptor(host) ? notifyTask(host, containerState) : notifyRender(host, containerState);\n    } else {\n        notifySignalOperation(subAction, containerState);\n    }\n};\n\nconst notifyRender = (hostElement, containerState) => {\n    const server = isServerPlatform();\n    server || resumeIfNeeded(containerState.$containerEl$);\n    const elCtx = getContext(hostElement, containerState);\n    if (assertDefined(elCtx.$componentQrl$, \"render: notified host element must have a defined $renderQrl$\", elCtx), \n    1 & elCtx.$flags$) {\n        return;\n    }\n    elCtx.$flags$ |= 1;\n    if (void 0 !== containerState.$hostsRendering$) {\n        containerState.$hostsStaging$.add(elCtx);\n    } else {\n        if (server) {\n            return void logWarn(\"Can not rerender in server platform\");\n        }\n        containerState.$hostsNext$.add(elCtx), scheduleFrame(containerState);\n    }\n};\n\nconst notifySignalOperation = (op, containerState) => {\n    const activeRendering = void 0 !== containerState.$hostsRendering$;\n    containerState.$opsNext$.add(op), activeRendering || scheduleFrame(containerState);\n};\n\nconst notifyTask = (task, containerState) => {\n    if (task.$flags$ & TaskFlagsIsDirty) {\n        return;\n    }\n    task.$flags$ |= TaskFlagsIsDirty;\n    void 0 !== containerState.$hostsRendering$ ? containerState.$taskStaging$.add(task) : (containerState.$taskNext$.add(task), \n    scheduleFrame(containerState));\n};\n\nconst scheduleFrame = containerState => (void 0 === containerState.$renderPromise$ && (containerState.$renderPromise$ = getPlatform().nextTick((() => renderMarked(containerState)))), \ncontainerState.$renderPromise$);\n\nconst _hW = () => {\n    const [task] = useLexicalScope();\n    notifyTask(task, _getContainerState(getWrappingContainer(task.$el$)));\n};\n\nconst renderMarked = async containerState => {\n    const containerEl = containerState.$containerEl$;\n    const doc = getDocument(containerEl);\n    try {\n        const rCtx = createRenderContext(doc, containerState);\n        const staticCtx = rCtx.$static$;\n        const hostsRendering = containerState.$hostsRendering$ = new Set(containerState.$hostsNext$);\n        containerState.$hostsNext$.clear(), await executeTasksBefore(containerState, rCtx), \n        containerState.$hostsStaging$.forEach((host => {\n            hostsRendering.add(host);\n        })), containerState.$hostsStaging$.clear();\n        const signalOperations = Array.from(containerState.$opsNext$);\n        containerState.$opsNext$.clear();\n        const renderingQueue = Array.from(hostsRendering);\n        if (sortNodes(renderingQueue), !containerState.$styleMoved$ && renderingQueue.length > 0) {\n            containerState.$styleMoved$ = !0;\n            (containerEl === doc.documentElement ? doc.body : containerEl).querySelectorAll(\"style[q\\\\:style]\").forEach((el => {\n                containerState.$styleIds$.add(directGetAttribute(el, QStyle)), appendChild(staticCtx, doc.head, el);\n            }));\n        }\n        for (const elCtx of renderingQueue) {\n            const el = elCtx.$element$;\n            if (!staticCtx.$hostElements$.has(el) && elCtx.$componentQrl$) {\n                assertTrue(el.isConnected, \"element must be connected to the dom\"), staticCtx.$roots$.push(elCtx);\n                try {\n                    await renderComponent(rCtx, elCtx, getFlags(el.parentElement));\n                } catch (err) {\n                    logError(err);\n                }\n            }\n        }\n        return signalOperations.forEach((op => {\n            executeSignalOperation(staticCtx, op);\n        })), staticCtx.$operations$.push(...staticCtx.$postOperations$), 0 === staticCtx.$operations$.length ? (printRenderStats(), \n        void await postRendering(containerState, rCtx)) : (await executeContextWithScrollAndTransition(staticCtx), \n        printRenderStats(), postRendering(containerState, rCtx));\n    } catch (err) {\n        logError(err);\n    }\n};\n\nconst getFlags = el => {\n    let flags = 0;\n    return el && (el.namespaceURI === SVG_NS && (flags |= 1), \"HEAD\" === el.tagName && (flags |= 2)), \n    flags;\n};\n\nconst postRendering = async (containerState, rCtx) => {\n    const hostElements = rCtx.$static$.$hostElements$;\n    await executeTasksAfter(containerState, rCtx, ((task, stage) => 0 != (task.$flags$ & TaskFlagsIsVisibleTask) && (!stage || hostElements.has(task.$el$)))), \n    containerState.$hostsStaging$.forEach((el => {\n        containerState.$hostsNext$.add(el);\n    })), containerState.$hostsStaging$.clear(), containerState.$hostsRendering$ = void 0, \n    containerState.$renderPromise$ = void 0;\n    containerState.$hostsNext$.size + containerState.$taskNext$.size + containerState.$opsNext$.size > 0 && (containerState.$renderPromise$ = renderMarked(containerState));\n};\n\nconst executeTasksBefore = async (containerState, rCtx) => {\n    const containerEl = containerState.$containerEl$;\n    const resourcesPromises = [];\n    const taskPromises = [];\n    const isTask = task => 0 != (task.$flags$ & TaskFlagsIsTask);\n    const isResourceTask = task => 0 != (task.$flags$ & TaskFlagsIsResource);\n    containerState.$taskNext$.forEach((task => {\n        isTask(task) && (taskPromises.push(then(task.$qrl$.$resolveLazy$(containerEl), (() => task))), \n        containerState.$taskNext$.delete(task)), isResourceTask(task) && (resourcesPromises.push(then(task.$qrl$.$resolveLazy$(containerEl), (() => task))), \n        containerState.$taskNext$.delete(task));\n    }));\n    do {\n        if (containerState.$taskStaging$.forEach((task => {\n            isTask(task) ? taskPromises.push(then(task.$qrl$.$resolveLazy$(containerEl), (() => task))) : isResourceTask(task) ? resourcesPromises.push(then(task.$qrl$.$resolveLazy$(containerEl), (() => task))) : containerState.$taskNext$.add(task);\n        })), containerState.$taskStaging$.clear(), taskPromises.length > 0) {\n            const tasks = await Promise.all(taskPromises);\n            sortTasks(tasks), await Promise.all(tasks.map((task => runSubscriber(task, containerState, rCtx)))), \n            taskPromises.length = 0;\n        }\n    } while (containerState.$taskStaging$.size > 0);\n    if (resourcesPromises.length > 0) {\n        const resources = await Promise.all(resourcesPromises);\n        sortTasks(resources), resources.forEach((task => runSubscriber(task, containerState, rCtx)));\n    }\n};\n\nconst executeTasksAfter = async (containerState, rCtx, taskPred) => {\n    const taskPromises = [];\n    const containerEl = containerState.$containerEl$;\n    containerState.$taskNext$.forEach((task => {\n        taskPred(task, !1) && (task.$el$.isConnected && taskPromises.push(then(task.$qrl$.$resolveLazy$(containerEl), (() => task))), \n        containerState.$taskNext$.delete(task));\n    }));\n    do {\n        if (containerState.$taskStaging$.forEach((task => {\n            task.$el$.isConnected && (taskPred(task, !0) ? taskPromises.push(then(task.$qrl$.$resolveLazy$(containerEl), (() => task))) : containerState.$taskNext$.add(task));\n        })), containerState.$taskStaging$.clear(), taskPromises.length > 0) {\n            const tasks = await Promise.all(taskPromises);\n            sortTasks(tasks);\n            for (const task of tasks) {\n                runSubscriber(task, containerState, rCtx);\n            }\n            taskPromises.length = 0;\n        }\n    } while (containerState.$taskStaging$.size > 0);\n};\n\nconst sortNodes = elements => {\n    elements.sort(((a, b) => 2 & a.$element$.compareDocumentPosition(getRootNode(b.$element$)) ? 1 : -1));\n};\n\nconst sortTasks = tasks => {\n    tasks.sort(((a, b) => a.$el$ === b.$el$ ? a.$index$ < b.$index$ ? -1 : 1 : 0 != (2 & a.$el$.compareDocumentPosition(getRootNode(b.$el$))) ? 1 : -1));\n};\n\nconst TaskFlagsIsVisibleTask = 1;\n\nconst TaskFlagsIsTask = 2;\n\nconst TaskFlagsIsResource = 4;\n\nconst TaskFlagsIsComputed = 8;\n\nconst TaskFlagsIsDirty = 16;\n\nconst TaskFlagsIsCleanup = 32;\n\nconst useTaskQrl = (qrl, opts) => {\n    const {get, set, iCtx, i, elCtx} = useSequentialScope();\n    if (get) {\n        return;\n    }\n    assertQrl(qrl);\n    const containerState = iCtx.$renderCtx$.$static$.$containerState$;\n    const task = new Task(TaskFlagsIsDirty | TaskFlagsIsTask, i, elCtx.$element$, qrl, void 0);\n    set(!0), qrl.$resolveLazy$(containerState.$containerEl$), elCtx.$tasks$ || (elCtx.$tasks$ = []), \n    elCtx.$tasks$.push(task), waitAndRun(iCtx, (() => runTask(task, containerState, iCtx.$renderCtx$))), \n    isServerPlatform() && useRunTask(task, opts?.eagerness);\n};\n\nconst useComputedQrl = qrl => {\n    const {get, set, iCtx, i, elCtx} = useSequentialScope();\n    if (get) {\n        return get;\n    }\n    assertQrl(qrl);\n    const containerState = iCtx.$renderCtx$.$static$.$containerState$;\n    const signal = _createSignal(void 0, containerState, 3, void 0);\n    const task = new Task(TaskFlagsIsDirty | TaskFlagsIsTask | 8, i, elCtx.$element$, qrl, signal);\n    return qrl.$resolveLazy$(containerState.$containerEl$), elCtx.$tasks$ || (elCtx.$tasks$ = []), \n    elCtx.$tasks$.push(task), waitAndRun(iCtx, (() => runComputed(task, containerState, iCtx.$renderCtx$))), \n    set(signal);\n};\n\nconst useComputed$ = implicit$FirstArg(useComputedQrl);\n\nconst useTask$ = /*#__PURE__*/ implicit$FirstArg(useTaskQrl);\n\nconst useVisibleTaskQrl = (qrl, opts) => {\n    const {get, set, i, iCtx, elCtx} = useSequentialScope();\n    const eagerness = opts?.strategy ?? \"intersection-observer\";\n    if (get) {\n        return void (isServerPlatform() && useRunTask(get, eagerness));\n    }\n    assertQrl(qrl);\n    const task = new Task(TaskFlagsIsVisibleTask, i, elCtx.$element$, qrl, void 0);\n    const containerState = iCtx.$renderCtx$.$static$.$containerState$;\n    elCtx.$tasks$ || (elCtx.$tasks$ = []), elCtx.$tasks$.push(task), set(task), useRunTask(task, eagerness), \n    isServerPlatform() || (qrl.$resolveLazy$(containerState.$containerEl$), notifyTask(task, containerState));\n};\n\nconst useVisibleTask$ = /*#__PURE__*/ implicit$FirstArg(useVisibleTaskQrl);\n\nconst isResourceTask = task => 0 != (task.$flags$ & TaskFlagsIsResource);\n\nconst isComputedTask = task => 0 != (8 & task.$flags$);\n\nconst runSubscriber = async (task, containerState, rCtx) => (assertEqual(!!(task.$flags$ & TaskFlagsIsDirty), !0, \"Resource is not dirty\", task), \nisResourceTask(task) ? runResource(task, containerState, rCtx) : isComputedTask(task) ? runComputed(task, containerState, rCtx) : runTask(task, containerState, rCtx));\n\nconst runResource = (task, containerState, rCtx, waitOn) => {\n    task.$flags$ &= ~TaskFlagsIsDirty, cleanupTask(task);\n    const iCtx = newInvokeContext(rCtx.$static$.$locale$, task.$el$, void 0, \"TaskEvent\");\n    const {$subsManager$: subsManager} = containerState;\n    iCtx.$renderCtx$ = rCtx;\n    const taskFn = task.$qrl$.getFn(iCtx, (() => {\n        subsManager.$clearSub$(task);\n    }));\n    const cleanups = [];\n    const resource = task.$state$;\n    assertDefined(resource, 'useResource: when running a resource, \"task.r\" must be a defined.', task);\n    const resourceTarget = unwrapProxy(resource);\n    const opts = {\n        track: (obj, prop) => {\n            if (isFunction(obj)) {\n                const ctx = newInvokeContext();\n                return ctx.$renderCtx$ = rCtx, ctx.$subscriber$ = [ 0, task ], invoke(ctx, obj);\n            }\n            const manager = getSubscriptionManager(obj);\n            return manager ? manager.$addSub$([ 0, task ], prop) : logErrorAndStop(codeToText(26), obj), \n            prop ? obj[prop] : isSignal(obj) ? obj.value : obj;\n        },\n        cleanup(callback) {\n            cleanups.push(callback);\n        },\n        cache(policy) {\n            let milliseconds = 0;\n            milliseconds = \"immutable\" === policy ? 1 / 0 : policy, resource._cache = milliseconds;\n        },\n        previous: resourceTarget._resolved\n    };\n    let resolve;\n    let reject;\n    let done = !1;\n    const setState = (resolved, value) => !done && (done = !0, resolved ? (done = !0, \n    resource.loading = !1, resource._state = \"resolved\", resource._resolved = value, \n    resource._error = void 0, resolve(value)) : (done = !0, resource.loading = !1, resource._state = \"rejected\", \n    resource._error = value, reject(value)), !0);\n    invoke(iCtx, (() => {\n        resource._state = \"pending\", resource.loading = !isServerPlatform(), resource.value = new Promise(((r, re) => {\n            resolve = r, reject = re;\n        }));\n    })), task.$destroy$ = noSerialize((() => {\n        done = !0, cleanups.forEach((fn => fn()));\n    }));\n    const promise = safeCall((() => then(waitOn, (() => taskFn(opts)))), (value => {\n        setState(!0, value);\n    }), (reason => {\n        setState(!1, reason);\n    }));\n    const timeout = resourceTarget._timeout;\n    return timeout > 0 ? Promise.race([ promise, delay(timeout).then((() => {\n        setState(!1, new Error(\"timeout\")) && cleanupTask(task);\n    })) ]) : promise;\n};\n\nconst runTask = (task, containerState, rCtx) => {\n    task.$flags$ &= ~TaskFlagsIsDirty, cleanupTask(task);\n    const hostElement = task.$el$;\n    const iCtx = newInvokeContext(rCtx.$static$.$locale$, hostElement, void 0, \"TaskEvent\");\n    iCtx.$renderCtx$ = rCtx;\n    const {$subsManager$: subsManager} = containerState;\n    const taskFn = task.$qrl$.getFn(iCtx, (() => {\n        subsManager.$clearSub$(task);\n    }));\n    const cleanups = [];\n    task.$destroy$ = noSerialize((() => {\n        cleanups.forEach((fn => fn()));\n    }));\n    const opts = {\n        track: (obj, prop) => {\n            if (isFunction(obj)) {\n                const ctx = newInvokeContext();\n                return ctx.$subscriber$ = [ 0, task ], invoke(ctx, obj);\n            }\n            const manager = getSubscriptionManager(obj);\n            return manager ? manager.$addSub$([ 0, task ], prop) : logErrorAndStop(codeToText(26), obj), \n            prop ? obj[prop] : obj;\n        },\n        cleanup(callback) {\n            cleanups.push(callback);\n        }\n    };\n    return safeCall((() => taskFn(opts)), (returnValue => {\n        isFunction(returnValue) && cleanups.push(returnValue);\n    }), (reason => {\n        handleError(reason, hostElement, rCtx);\n    }));\n};\n\nconst runComputed = (task, containerState, rCtx) => {\n    assertSignal(task.$state$), task.$flags$ &= ~TaskFlagsIsDirty, cleanupTask(task);\n    const hostElement = task.$el$;\n    const iCtx = newInvokeContext(rCtx.$static$.$locale$, hostElement, void 0, \"ComputedEvent\");\n    iCtx.$subscriber$ = [ 0, task ], iCtx.$renderCtx$ = rCtx;\n    const {$subsManager$: subsManager} = containerState;\n    const taskFn = task.$qrl$.getFn(iCtx, (() => {\n        subsManager.$clearSub$(task);\n    }));\n    return safeCall(taskFn, (returnValue => untrack((() => {\n        const signal = task.$state$;\n        signal[QObjectSignalFlags] &= -3, signal.untrackedValue = returnValue, signal[QObjectManagerSymbol].$notifySubs$();\n    }))), (reason => {\n        handleError(reason, hostElement, rCtx);\n    }));\n};\n\nconst cleanupTask = task => {\n    const destroy = task.$destroy$;\n    if (destroy) {\n        task.$destroy$ = void 0;\n        try {\n            destroy();\n        } catch (err) {\n            logError(err);\n        }\n    }\n};\n\nconst destroyTask = task => {\n    if (32 & task.$flags$) {\n        task.$flags$ &= -33;\n        (0, task.$qrl$)();\n    } else {\n        cleanupTask(task);\n    }\n};\n\nconst useRunTask = (task, eagerness) => {\n    \"visible\" === eagerness || \"intersection-observer\" === eagerness ? useOn(\"qvisible\", getTaskHandlerQrl(task)) : \"load\" === eagerness || \"document-ready\" === eagerness ? useOnDocument(\"qinit\", getTaskHandlerQrl(task)) : \"idle\" !== eagerness && \"document-idle\" !== eagerness || useOnDocument(\"qidle\", getTaskHandlerQrl(task));\n};\n\nconst getTaskHandlerQrl = task => {\n    const taskQrl = task.$qrl$;\n    return createQRL(taskQrl.$chunk$, \"_hW\", _hW, null, null, [ task ], taskQrl.$symbol$);\n};\n\nconst isSubscriberDescriptor = obj => isObject(obj) && obj instanceof Task;\n\nconst serializeTask = (task, getObjId) => {\n    let value = `${intToStr(task.$flags$)} ${intToStr(task.$index$)} ${getObjId(task.$qrl$)} ${getObjId(task.$el$)}`;\n    return task.$state$ && (value += ` ${getObjId(task.$state$)}`), value;\n};\n\nconst parseTask = data => {\n    const [flags, index, qrl, el, resource] = data.split(\" \");\n    return new Task(strToInt(flags), strToInt(index), el, qrl, resource);\n};\n\nclass Task {\n    constructor($flags$, $index$, $el$, $qrl$, $state$) {\n        this.$flags$ = $flags$, this.$index$ = $index$, this.$el$ = $el$, this.$qrl$ = $qrl$, \n        this.$state$ = $state$;\n    }\n}\n\nconst _serializeData = async data => {\n    const containerState = {};\n    const collector = createCollector(containerState);\n    let promises;\n    for (collectValue(data, collector, !1); (promises = collector.$promises$).length > 0; ) {\n        collector.$promises$ = [], await Promise.all(promises);\n    }\n    const objs = Array.from(collector.$objSet$.keys());\n    let count = 0;\n    const objToId = new Map;\n    for (const obj of objs) {\n        objToId.set(obj, intToStr(count)), count++;\n    }\n    if (collector.$noSerialize$.length > 0) {\n        const undefinedID = objToId.get(void 0);\n        assertDefined(undefinedID, \"undefined ID must be defined\");\n        for (const obj of collector.$noSerialize$) {\n            objToId.set(obj, undefinedID);\n        }\n    }\n    const mustGetObjId = obj => {\n        let suffix = \"\";\n        if (isPromise(obj)) {\n            const promiseValue = getPromiseValue(obj);\n            if (!promiseValue) {\n                throw qError(27, obj);\n            }\n            obj = promiseValue.value, suffix += promiseValue.resolved ? \"~\" : \"_\";\n        }\n        if (isObject(obj)) {\n            const target = getProxyTarget(obj);\n            target && (suffix += \"!\", obj = target);\n        }\n        const key = objToId.get(obj);\n        if (void 0 === key) {\n            throw qError(27, obj);\n        }\n        return key + suffix;\n    };\n    const convertedObjs = objs.map((obj => {\n        if (null === obj) {\n            return null;\n        }\n        const typeObj = typeof obj;\n        switch (typeObj) {\n          case \"undefined\":\n            return UNDEFINED_PREFIX;\n\n          case \"number\":\n            if (!Number.isFinite(obj)) {\n                break;\n            }\n            return obj;\n\n          case \"string\":\n          case \"boolean\":\n            return obj;\n        }\n        const value = serializeValue(obj, mustGetObjId, collector, containerState);\n        if (void 0 !== value) {\n            return value;\n        }\n        if (\"object\" === typeObj) {\n            if (isArray(obj)) {\n                return obj.map(mustGetObjId);\n            }\n            if (isSerializableObject(obj)) {\n                const output = {};\n                for (const key in obj) {\n                    output[key] = mustGetObjId(obj[key]);\n                }\n                return output;\n            }\n        }\n        throw qError(3, obj);\n    }));\n    return JSON.stringify({\n        _entry: mustGetObjId(data),\n        _objs: convertedObjs\n    });\n};\n\nconst pauseContainer = async (elmOrDoc, defaultParentJSON) => {\n    const doc = getDocument(elmOrDoc);\n    const documentElement = doc.documentElement;\n    const containerEl = isDocument(elmOrDoc) ? documentElement : elmOrDoc;\n    if (\"paused\" === directGetAttribute(containerEl, \"q:container\")) {\n        throw qError(21);\n    }\n    const parentJSON = defaultParentJSON ?? (containerEl === doc.documentElement ? doc.body : containerEl);\n    const containerState = _getContainerState(containerEl);\n    const contexts = getNodesInScope(containerEl, hasContext);\n    directSetAttribute(containerEl, \"q:container\", \"paused\");\n    for (const elCtx of contexts) {\n        const elm = elCtx.$element$;\n        const listeners = elCtx.li;\n        if (elCtx.$scopeIds$) {\n            const value = serializeSStyle(elCtx.$scopeIds$);\n            value && elm.setAttribute(\"q:sstyle\", value);\n        }\n        if (elCtx.$id$ && elm.setAttribute(\"q:id\", elCtx.$id$), isElement$1(elm) && listeners.length > 0) {\n            const groups = groupListeners(listeners);\n            for (const listener of groups) {\n                elm.setAttribute(listener[0], serializeQRLs(listener[1], elCtx));\n            }\n        }\n    }\n    const data = await _pauseFromContexts(contexts, containerState, (el => isNode$1(el) && isText(el) ? getTextID(el, containerState) : null));\n    const qwikJson = doc.createElement(\"script\");\n    directSetAttribute(qwikJson, \"type\", \"qwik/json\"), qwikJson.textContent = escapeText(JSON.stringify(data.state, void 0, void 0)), \n    parentJSON.appendChild(qwikJson);\n    const extraListeners = Array.from(containerState.$events$, (s => JSON.stringify(s)));\n    const eventsScript = doc.createElement(\"script\");\n    return eventsScript.textContent = `window.qwikevents||=[];window.qwikevents.push(${extraListeners.join(\", \")})`, \n    parentJSON.appendChild(eventsScript), data;\n};\n\nconst _pauseFromContexts = async (allContexts, containerState, fallbackGetObjId, textNodes) => {\n    const collector = createCollector(containerState);\n    textNodes?.forEach(((_, key) => {\n        collector.$seen$.add(key);\n    }));\n    let hasListeners = !1;\n    for (const ctx of allContexts) {\n        if (ctx.$tasks$) {\n            for (const task of ctx.$tasks$) {\n                isResourceTask(task) && collector.$resources$.push(task.$state$), destroyTask(task);\n            }\n        }\n    }\n    for (const ctx of allContexts) {\n        const el = ctx.$element$;\n        const ctxListeners = ctx.li;\n        for (const listener of ctxListeners) {\n            if (isElement$1(el)) {\n                const qrl = listener[1];\n                const captured = qrl.$captureRef$;\n                if (captured) {\n                    for (const obj of captured) {\n                        collectValue(obj, collector, !0);\n                    }\n                }\n                collector.$qrls$.push(qrl), hasListeners = !0;\n            }\n        }\n    }\n    if (!hasListeners) {\n        return {\n            state: {\n                refs: {},\n                ctx: {},\n                objs: [],\n                subs: []\n            },\n            objs: [],\n            funcs: [],\n            qrls: [],\n            resources: collector.$resources$,\n            mode: \"static\"\n        };\n    }\n    let promises;\n    for (;(promises = collector.$promises$).length > 0; ) {\n        collector.$promises$ = [], await Promise.all(promises);\n    }\n    const canRender = collector.$elements$.length > 0;\n    if (canRender) {\n        for (const elCtx of collector.$deferElements$) {\n            collectElementData(elCtx, collector, elCtx.$element$);\n        }\n        for (const ctx of allContexts) {\n            collectProps(ctx, collector);\n        }\n    }\n    for (;(promises = collector.$promises$).length > 0; ) {\n        collector.$promises$ = [], await Promise.all(promises);\n    }\n    const elementToIndex = new Map;\n    const objs = Array.from(collector.$objSet$.keys());\n    const objToId = new Map;\n    const getObjId = obj => {\n        let suffix = \"\";\n        if (isPromise(obj)) {\n            const promiseValue = getPromiseValue(obj);\n            if (!promiseValue) {\n                return null;\n            }\n            obj = promiseValue.value, suffix += promiseValue.resolved ? \"~\" : \"_\";\n        }\n        if (isObject(obj)) {\n            const target = getProxyTarget(obj);\n            if (target) {\n                suffix += \"!\", obj = target;\n            } else if (isQwikElement(obj)) {\n                const elID = (el => {\n                    let id = elementToIndex.get(el);\n                    return void 0 === id && (id = getQId(el), id || console.warn(\"Missing ID\", el), \n                    elementToIndex.set(el, id)), id;\n                })(obj);\n                return elID ? \"#\" + elID + suffix : null;\n            }\n        }\n        const id = objToId.get(obj);\n        if (id) {\n            return id + suffix;\n        }\n        const textId = textNodes?.get(obj);\n        return textId ? \"*\" + textId : fallbackGetObjId ? fallbackGetObjId(obj) : null;\n    };\n    const mustGetObjId = obj => {\n        const key = getObjId(obj);\n        if (null === key) {\n            throw qError(27, obj);\n        }\n        return key;\n    };\n    const subsMap = new Map;\n    for (const obj of objs) {\n        const subs = getManager(obj, containerState)?.$subs$;\n        if (!subs) {\n            continue;\n        }\n        const flags = getProxyFlags(obj) ?? 0;\n        const converted = [];\n        1 & flags && converted.push(flags);\n        for (const sub of subs) {\n            const host = sub[1];\n            0 === sub[0] && isNode$1(host) && isVirtualElement(host) && !collector.$elements$.includes(tryGetContext(host)) || converted.push(sub);\n        }\n        converted.length > 0 && subsMap.set(obj, converted);\n    }\n    objs.sort(((a, b) => (subsMap.has(a) ? 0 : 1) - (subsMap.has(b) ? 0 : 1)));\n    let count = 0;\n    for (const obj of objs) {\n        objToId.set(obj, intToStr(count)), count++;\n    }\n    if (collector.$noSerialize$.length > 0) {\n        const undefinedID = objToId.get(void 0);\n        assertDefined(undefinedID, \"undefined ID must be defined\");\n        for (const obj of collector.$noSerialize$) {\n            objToId.set(obj, undefinedID);\n        }\n    }\n    const subs = [];\n    for (const obj of objs) {\n        const value = subsMap.get(obj);\n        if (null == value) {\n            break;\n        }\n        subs.push(value.map((s => \"number\" == typeof s ? `_${s}` : serializeSubscription(s, getObjId))).filter(isNotNullable));\n    }\n    assertEqual(subs.length, subsMap.size, \"missing subscriptions to serialize\", subs, subsMap);\n    const convertedObjs = objs.map((obj => {\n        if (null === obj) {\n            return null;\n        }\n        const typeObj = typeof obj;\n        switch (typeObj) {\n          case \"undefined\":\n            return UNDEFINED_PREFIX;\n\n          case \"number\":\n            if (!Number.isFinite(obj)) {\n                break;\n            }\n            return obj;\n\n          case \"string\":\n          case \"boolean\":\n            return obj;\n        }\n        const value = serializeValue(obj, mustGetObjId, collector, containerState);\n        if (void 0 !== value) {\n            return value;\n        }\n        if (\"object\" === typeObj) {\n            if (isArray(obj)) {\n                return obj.map(mustGetObjId);\n            }\n            if (isSerializableObject(obj)) {\n                const output = {};\n                for (const key in obj) {\n                    const id = getObjId(obj[key]);\n                    null !== id && (output[key] = id);\n                }\n                return output;\n            }\n        }\n        throw qError(3, obj);\n    }));\n    const meta = {};\n    const refs = {};\n    for (const ctx of allContexts) {\n        const node = ctx.$element$;\n        const elementID = ctx.$id$;\n        const ref = ctx.$refMap$;\n        const props = ctx.$props$;\n        const contexts = ctx.$contexts$;\n        const tasks = ctx.$tasks$;\n        const renderQrl = ctx.$componentQrl$;\n        const seq = ctx.$seq$;\n        const metaValue = {};\n        const elementCaptured = isVirtualElement(node) && collector.$elements$.includes(ctx);\n        if (assertDefined(elementID, \"pause: can not generate ID for dom node\", node), ref.length > 0) {\n            assertElement(node);\n            const value = mapJoin(ref, mustGetObjId, \" \");\n            value && (refs[elementID] = value);\n        } else if (canRender) {\n            let add = !1;\n            if (elementCaptured) {\n                assertDefined(renderQrl, \"renderQrl must be defined\");\n                const propsId = getObjId(props);\n                metaValue.h = mustGetObjId(renderQrl) + (propsId ? \" \" + propsId : \"\"), add = !0;\n            } else {\n                const propsId = getObjId(props);\n                propsId && (metaValue.h = \" \" + propsId, add = !0);\n            }\n            if (tasks && tasks.length > 0) {\n                const value = mapJoin(tasks, getObjId, \" \");\n                value && (metaValue.w = value, add = !0);\n            }\n            if (elementCaptured && seq && seq.length > 0) {\n                const value = mapJoin(seq, mustGetObjId, \" \");\n                metaValue.s = value, add = !0;\n            }\n            if (contexts) {\n                const serializedContexts = [];\n                contexts.forEach(((value, key) => {\n                    const id = getObjId(value);\n                    id && serializedContexts.push(`${key}=${id}`);\n                }));\n                const value = serializedContexts.join(\" \");\n                value && (metaValue.c = value, add = !0);\n            }\n            add && (meta[elementID] = metaValue);\n        }\n    }\n    return {\n        state: {\n            refs,\n            ctx: meta,\n            objs: convertedObjs,\n            subs\n        },\n        objs,\n        funcs: collector.$inlinedFunctions$,\n        resources: collector.$resources$,\n        qrls: collector.$qrls$,\n        mode: canRender ? \"render\" : \"listeners\"\n    };\n};\n\nconst mapJoin = (objects, getObjectId, sep) => {\n    let output = \"\";\n    for (const obj of objects) {\n        const id = getObjectId(obj);\n        null !== id && (\"\" !== output && (output += sep), output += id);\n    }\n    return output;\n};\n\nconst getNodesInScope = (parent, predicate) => {\n    const results = [];\n    const v = predicate(parent);\n    void 0 !== v && results.push(v);\n    const walker = parent.ownerDocument.createTreeWalker(parent, 129, {\n        acceptNode(node) {\n            if (isContainer(node)) {\n                return 2;\n            }\n            const v = predicate(node);\n            return void 0 !== v && results.push(v), 3;\n        }\n    });\n    for (;walker.nextNode(); ) {}\n    return results;\n};\n\nconst collectProps = (elCtx, collector) => {\n    const parentCtx = elCtx.$parent$;\n    const props = elCtx.$props$;\n    if (parentCtx && props && !isEmptyObj(props) && collector.$elements$.includes(parentCtx)) {\n        const subs = getSubscriptionManager(props)?.$subs$;\n        const el = elCtx.$element$;\n        if (subs) {\n            for (const [type, host] of subs) {\n                0 === type ? (host !== el && collectSubscriptions(getSubscriptionManager(props), collector, !1), \n                isNode$1(host) ? collectElement(host, collector) : collectValue(host, collector, !0)) : (collectValue(props, collector, !1), \n                collectSubscriptions(getSubscriptionManager(props), collector, !1));\n            }\n        }\n    }\n};\n\nconst createCollector = containerState => ({\n    $containerState$: containerState,\n    $seen$: new Set,\n    $objSet$: new Set,\n    $prefetch$: 0,\n    $noSerialize$: [],\n    $inlinedFunctions$: [],\n    $resources$: [],\n    $elements$: [],\n    $qrls$: [],\n    $deferElements$: [],\n    $promises$: []\n});\n\nconst collectDeferElement = (el, collector) => {\n    const ctx = tryGetContext(el);\n    collector.$elements$.includes(ctx) || (collector.$elements$.push(ctx), collector.$prefetch$++, \n    8 & ctx.$flags$ ? collectElementData(ctx, collector, !0) : collector.$deferElements$.push(ctx), \n    collector.$prefetch$--);\n};\n\nconst collectElement = (el, collector) => {\n    const ctx = tryGetContext(el);\n    if (ctx) {\n        if (collector.$elements$.includes(ctx)) {\n            return;\n        }\n        collector.$elements$.push(ctx), collectElementData(ctx, collector, el);\n    }\n};\n\nconst collectElementData = (elCtx, collector, dynamicCtx) => {\n    if (elCtx.$props$ && !isEmptyObj(elCtx.$props$) && (collectValue(elCtx.$props$, collector, dynamicCtx), \n    collectSubscriptions(getSubscriptionManager(elCtx.$props$), collector, dynamicCtx)), \n    elCtx.$componentQrl$ && collectValue(elCtx.$componentQrl$, collector, dynamicCtx), \n    elCtx.$seq$) {\n        for (const obj of elCtx.$seq$) {\n            collectValue(obj, collector, dynamicCtx);\n        }\n    }\n    if (elCtx.$tasks$) {\n        const map = collector.$containerState$.$subsManager$.$groupToManagers$;\n        for (const obj of elCtx.$tasks$) {\n            map.has(obj) && collectValue(obj, collector, dynamicCtx);\n        }\n    }\n    if (!0 === dynamicCtx && (collectContext(elCtx, collector), elCtx.$dynamicSlots$)) {\n        for (const slotCtx of elCtx.$dynamicSlots$) {\n            collectContext(slotCtx, collector);\n        }\n    }\n};\n\nconst collectContext = (elCtx, collector) => {\n    for (;elCtx; ) {\n        if (elCtx.$contexts$) {\n            for (const obj of elCtx.$contexts$.values()) {\n                collectValue(obj, collector, !0);\n            }\n            if (!0 === elCtx.$contexts$.get(\"_\")) {\n                break;\n            }\n        }\n        elCtx = elCtx.$slotParent$ ?? elCtx.$parent$;\n    }\n};\n\nconst escapeText = str => str.replace(/<(\\/?script)/g, \"\\\\x3C$1\");\n\nconst collectSubscriptions = (manager, collector, leaks) => {\n    if (collector.$seen$.has(manager)) {\n        return;\n    }\n    collector.$seen$.add(manager);\n    const subs = manager.$subs$;\n    assertDefined(subs, \"subs must be defined\");\n    for (const key of subs) {\n        const type = key[0];\n        if (type > 0 && collectValue(key[2], collector, leaks), !0 === leaks) {\n            const host = key[1];\n            isNode$1(host) && isVirtualElement(host) ? 0 === type && collectDeferElement(host, collector) : collectValue(host, collector, !0);\n        }\n    }\n};\n\nconst PROMISE_VALUE = Symbol();\n\nconst resolvePromise = promise => promise.then((value => (promise[PROMISE_VALUE] = {\n    resolved: !0,\n    value\n}, value)), (value => (promise[PROMISE_VALUE] = {\n    resolved: !1,\n    value\n}, value)));\n\nconst getPromiseValue = promise => promise[PROMISE_VALUE];\n\nconst collectValue = (obj, collector, leaks) => {\n    if (null !== obj) {\n        const objType = typeof obj;\n        switch (objType) {\n          case \"function\":\n          case \"object\":\n            {\n                const seen = collector.$seen$;\n                if (seen.has(obj)) {\n                    return;\n                }\n                if (seen.add(obj), fastSkipSerialize(obj)) {\n                    return collector.$objSet$.add(void 0), void collector.$noSerialize$.push(obj);\n                }\n                const input = obj;\n                const target = getProxyTarget(obj);\n                if (target) {\n                    const mutable = 0 == (2 & getProxyFlags(obj = target));\n                    if (leaks && mutable && collectSubscriptions(getSubscriptionManager(input), collector, leaks), \n                    fastWeakSerialize(input)) {\n                        return void collector.$objSet$.add(obj);\n                    }\n                }\n                if (collectDeps(obj, collector, leaks)) {\n                    return void collector.$objSet$.add(obj);\n                }\n                if (isPromise(obj)) {\n                    return void collector.$promises$.push((promise = obj, promise.then((value => (promise[PROMISE_VALUE] = {\n                        resolved: !0,\n                        value\n                    }, value)), (value => (promise[PROMISE_VALUE] = {\n                        resolved: !1,\n                        value\n                    }, value)))).then((value => {\n                        collectValue(value, collector, leaks);\n                    })));\n                }\n                if (\"object\" === objType) {\n                    if (isNode$1(obj)) {\n                        return;\n                    }\n                    if (isArray(obj)) {\n                        for (let i = 0; i < obj.length; i++) {\n                            collectValue(input[i], collector, leaks);\n                        }\n                    } else if (isSerializableObject(obj)) {\n                        for (const key in obj) {\n                            collectValue(input[key], collector, leaks);\n                        }\n                    }\n                }\n                break;\n            }\n\n          case \"string\":\n            if (collector.$seen$.has(obj)) {\n                return;\n            }\n        }\n    }\n    var promise;\n    collector.$objSet$.add(obj);\n};\n\nconst isContainer = el => isElement$1(el) && el.hasAttribute(\"q:container\");\n\nconst hasContext = el => {\n    const node = processVirtualNodes(el);\n    if (isQwikElement(node)) {\n        const ctx = tryGetContext(node);\n        if (ctx && ctx.$id$) {\n            return ctx;\n        }\n    }\n};\n\nconst getManager = (obj, containerState) => {\n    if (!isObject(obj)) {\n        return;\n    }\n    if (obj instanceof SignalImpl) {\n        return getSubscriptionManager(obj);\n    }\n    const proxy = containerState.$proxyMap$.get(obj);\n    return proxy ? getSubscriptionManager(proxy) : void 0;\n};\n\nconst getQId = el => {\n    const ctx = tryGetContext(el);\n    return ctx ? ctx.$id$ : null;\n};\n\nconst getTextID = (node, containerState) => {\n    const prev = node.previousSibling;\n    if (prev && isComment(prev) && prev.data.startsWith(\"t=\")) {\n        return \"#\" + prev.data.slice(2);\n    }\n    const doc = node.ownerDocument;\n    const id = intToStr(containerState.$elementIndex$++);\n    const open = doc.createComment(`t=${id}`);\n    const close = doc.createComment(\"\");\n    const parent = node.parentElement;\n    return parent.insertBefore(open, node), parent.insertBefore(close, node.nextSibling), \n    \"#\" + id;\n};\n\nconst isEmptyObj = obj => 0 === Object.keys(obj).length;\n\nconst EXTRACT_IMPORT_PATH = /\\(\\s*(['\"])([^\\1]+)\\1\\s*\\)/;\n\nconst EXTRACT_SELF_IMPORT = /Promise\\s*\\.\\s*resolve/;\n\nconst EXTRACT_FILE_NAME = /[\\\\/(]([\\w\\d.\\-_]+\\.(js|ts)x?):/;\n\nconst announcedQRL = /*#__PURE__*/ new Set;\n\nconst qrl = (chunkOrFn, symbol, lexicalScopeCapture = EMPTY_ARRAY, stackOffset = 0) => {\n    let chunk = null;\n    let symbolFn = null;\n    if (isFunction(chunkOrFn)) {\n        symbolFn = chunkOrFn;\n        {\n            let match;\n            const srcCode = String(chunkOrFn);\n            if ((match = srcCode.match(EXTRACT_IMPORT_PATH)) && match[2]) {\n                chunk = match[2];\n            } else {\n                if (!(match = srcCode.match(EXTRACT_SELF_IMPORT))) {\n                    throw qError(11, srcCode);\n                }\n                {\n                    const ref = \"QWIK-SELF\";\n                    const frames = new Error(ref).stack.split(\"\\n\");\n                    const start = frames.findIndex((f => f.includes(ref)));\n                    match = frames[start + 2 + stackOffset].match(EXTRACT_FILE_NAME), chunk = match ? match[1] : \"main\";\n                }\n            }\n        }\n    } else {\n        if (!isString(chunkOrFn)) {\n            throw qError(12, chunkOrFn);\n        }\n        chunk = chunkOrFn;\n    }\n    return announcedQRL.has(symbol) || (announcedQRL.add(symbol), emitEvent(\"qprefetch\", {\n        symbols: [ getSymbolHash(symbol) ]\n    })), createQRL(chunk, symbol, null, symbolFn, null, lexicalScopeCapture, null);\n};\n\nconst inlinedQrl = (symbol, symbolName, lexicalScopeCapture = EMPTY_ARRAY) => createQRL(null, symbolName, symbol, null, null, lexicalScopeCapture, null);\n\nconst _noopQrl = (symbolName, lexicalScopeCapture = EMPTY_ARRAY) => createQRL(null, symbolName, null, null, null, lexicalScopeCapture, null);\n\nconst qrlDEV = (chunkOrFn, symbol, opts, lexicalScopeCapture = EMPTY_ARRAY) => {\n    const newQrl = qrl(chunkOrFn, symbol, lexicalScopeCapture, 1);\n    return newQrl.dev = opts, newQrl;\n};\n\nconst inlinedQrlDEV = (symbol, symbolName, opts, lexicalScopeCapture = EMPTY_ARRAY) => {\n    const qrl = inlinedQrl(symbol, symbolName, lexicalScopeCapture);\n    return qrl.dev = opts, qrl;\n};\n\nconst serializeQRL = (qrl, opts = {}) => {\n    assertTrue(true, \"In order to serialize a QRL, qSerialize must be true\"), assertQrl(qrl);\n    let symbol = qrl.$symbol$;\n    let chunk = qrl.$chunk$;\n    const refSymbol = qrl.$refSymbol$ ?? symbol;\n    const platform = getPlatform();\n    if (platform) {\n        const result = platform.chunkForSymbol(refSymbol, chunk);\n        result && (chunk = result[1], qrl.$refSymbol$ || (symbol = result[0]));\n    }\n    if (!chunk) {\n        throw qError(31, qrl.$symbol$);\n    }\n    chunk.startsWith(\"./\") && (chunk = chunk.slice(2));\n    let output = `${chunk}#${symbol}`;\n    const capture = qrl.$capture$;\n    const captureRef = qrl.$captureRef$;\n    return captureRef && captureRef.length ? opts.$getObjId$ ? output += `[${mapJoin(captureRef, opts.$getObjId$, \" \")}]` : opts.$addRefMap$ && (output += `[${mapJoin(captureRef, opts.$addRefMap$, \" \")}]`) : capture && capture.length > 0 && (output += `[${capture.join(\" \")}]`), \n    output;\n};\n\nconst serializeQRLs = (existingQRLs, elCtx) => {\n    assertElement(elCtx.$element$);\n    const opts = {\n        $addRefMap$: obj => addToArray(elCtx.$refMap$, obj)\n    };\n    return mapJoin(existingQRLs, (qrl => serializeQRL(qrl, opts)), \"\\n\");\n};\n\nconst parseQRL = (qrl, containerEl) => {\n    const endIdx = qrl.length;\n    const hashIdx = indexOf(qrl, 0, \"#\");\n    const captureIdx = indexOf(qrl, hashIdx, \"[\");\n    const chunkEndIdx = Math.min(hashIdx, captureIdx);\n    const chunk = qrl.substring(0, chunkEndIdx);\n    const symbolStartIdx = hashIdx == endIdx ? hashIdx : hashIdx + 1;\n    const symbol = symbolStartIdx == captureIdx ? \"default\" : qrl.substring(symbolStartIdx, captureIdx);\n    const capture = captureIdx === endIdx ? EMPTY_ARRAY : qrl.substring(captureIdx + 1, endIdx - 1).split(\" \");\n    const iQrl = createQRL(chunk, symbol, null, null, capture, null, null);\n    return containerEl && iQrl.$setContainer$(containerEl), iQrl;\n};\n\nconst indexOf = (text, startIdx, char) => {\n    const endIdx = text.length;\n    const charIdx = text.indexOf(char, startIdx == endIdx ? 0 : startIdx);\n    return -1 == charIdx ? endIdx : charIdx;\n};\n\nconst addToArray = (array, obj) => {\n    const index = array.indexOf(obj);\n    return -1 === index ? (array.push(obj), String(array.length - 1)) : String(index);\n};\n\nconst inflateQrl = (qrl, elCtx) => (assertDefined(qrl.$capture$, \"invoke: qrl capture must be defined inside useLexicalScope()\", qrl), \nqrl.$captureRef$ = qrl.$capture$.map((idx => {\n    const int = parseInt(idx, 10);\n    const obj = elCtx.$refMap$[int];\n    return assertTrue(elCtx.$refMap$.length > int, \"out of bounds inflate access\", idx), \n    obj;\n})));\n\nconst _regSymbol = (symbol, hash) => (void 0 === globalThis.__qwik_reg_symbols && (globalThis.__qwik_reg_symbols = new Map), \nglobalThis.__qwik_reg_symbols.set(hash, symbol), symbol);\n\nconst useResourceQrl = (qrl, opts) => {\n    const {get, set, i, iCtx, elCtx} = useSequentialScope();\n    if (null != get) {\n        return get;\n    }\n    assertQrl(qrl);\n    const containerState = iCtx.$renderCtx$.$static$.$containerState$;\n    const resource = createResourceReturn(containerState, opts);\n    const task = new Task(TaskFlagsIsDirty | TaskFlagsIsResource, i, elCtx.$element$, qrl, resource);\n    const previousWait = Promise.all(iCtx.$waitOn$.slice());\n    return runResource(task, containerState, iCtx.$renderCtx$, previousWait), elCtx.$tasks$ || (elCtx.$tasks$ = []), \n    elCtx.$tasks$.push(task), set(resource), resource;\n};\n\nconst useResource$ = (generatorFn, opts) => useResourceQrl($(generatorFn), opts);\n\nconst Resource = props => {\n    const isBrowser = !isServerPlatform();\n    const resource = props.value;\n    let promise;\n    if (isResourceReturn(resource)) {\n        if (isBrowser) {\n            if (props.onRejected && (resource.value.catch((() => {})), \"rejected\" === resource._state)) {\n                return props.onRejected(resource._error);\n            }\n            if (props.onPending) {\n                const state = resource._state;\n                if (\"resolved\" === state) {\n                    return props.onResolved(resource._resolved);\n                }\n                if (\"pending\" === state) {\n                    return props.onPending();\n                }\n                if (\"rejected\" === state) {\n                    throw resource._error;\n                }\n            }\n            if (void 0 !== untrack((() => resource._resolved))) {\n                return props.onResolved(resource._resolved);\n            }\n        }\n        promise = resource.value;\n    } else if (isPromise(resource)) {\n        promise = resource;\n    } else {\n        if (!isSignal(resource)) {\n            return props.onResolved(resource);\n        }\n        promise = Promise.resolve(resource.value);\n    }\n    return jsx(Fragment, {\n        children: promise.then(useBindInvokeContext(props.onResolved), useBindInvokeContext(props.onRejected))\n    });\n};\n\nconst _createResourceReturn = opts => ({\n    __brand: \"resource\",\n    value: void 0,\n    loading: !isServerPlatform(),\n    _resolved: void 0,\n    _error: void 0,\n    _state: \"pending\",\n    _timeout: opts?.timeout ?? -1,\n    _cache: 0\n});\n\nconst createResourceReturn = (containerState, opts, initialPromise) => {\n    const result = _createResourceReturn(opts);\n    result.value = initialPromise;\n    return createProxy(result, containerState, void 0);\n};\n\nconst isResourceReturn = obj => isObject(obj) && \"resource\" === obj.__brand;\n\nconst serializeResource = (resource, getObjId) => {\n    const state = resource._state;\n    return \"resolved\" === state ? `0 ${getObjId(resource._resolved)}` : \"pending\" === state ? \"1\" : `2 ${getObjId(resource._error)}`;\n};\n\nconst parseResourceReturn = data => {\n    const [first, id] = data.split(\" \");\n    const result = _createResourceReturn(void 0);\n    return result.value = Promise.resolve(), \"0\" === first ? (result._state = \"resolved\", \n    result._resolved = id, result.loading = !1) : \"1\" === first ? (result._state = \"pending\", \n    result.value = new Promise((() => {})), result.loading = !0) : \"2\" === first && (result._state = \"rejected\", \n    result._error = id, result.loading = !1), result;\n};\n\nconst Slot = props => _jsxC(Virtual, {\n    \"q:s\": \"\"\n}, 0, props.name ?? \"\");\n\nconst UNDEFINED_PREFIX = \"\u0001\";\n\nconst QRLSerializer = {\n    $prefix$: \"\u0002\",\n    $test$: v => isQrl(v),\n    $collect$: (v, collector, leaks) => {\n        if (v.$captureRef$) {\n            for (const item of v.$captureRef$) {\n                collectValue(item, collector, leaks);\n            }\n        }\n        0 === collector.$prefetch$ && collector.$qrls$.push(v);\n    },\n    $serialize$: (obj, getObjId) => serializeQRL(obj, {\n        $getObjId$: getObjId\n    }),\n    $prepare$: (data, containerState) => parseQRL(data, containerState.$containerEl$),\n    $fill$: (qrl, getObject) => {\n        qrl.$capture$ && qrl.$capture$.length > 0 && (qrl.$captureRef$ = qrl.$capture$.map(getObject), \n        qrl.$capture$ = null);\n    }\n};\n\nconst TaskSerializer = {\n    $prefix$: \"\u0003\",\n    $test$: v => isSubscriberDescriptor(v),\n    $collect$: (v, collector, leaks) => {\n        collectValue(v.$qrl$, collector, leaks), v.$state$ && (collectValue(v.$state$, collector, leaks), \n        !0 === leaks && v.$state$ instanceof SignalImpl && collectSubscriptions(v.$state$[QObjectManagerSymbol], collector, !0));\n    },\n    $serialize$: (obj, getObjId) => serializeTask(obj, getObjId),\n    $prepare$: data => parseTask(data),\n    $fill$: (task, getObject) => {\n        task.$el$ = getObject(task.$el$), task.$qrl$ = getObject(task.$qrl$), task.$state$ && (task.$state$ = getObject(task.$state$));\n    }\n};\n\nconst ResourceSerializer = {\n    $prefix$: \"\u0004\",\n    $test$: v => isResourceReturn(v),\n    $collect$: (obj, collector, leaks) => {\n        collectValue(obj.value, collector, leaks), collectValue(obj._resolved, collector, leaks);\n    },\n    $serialize$: (obj, getObjId) => serializeResource(obj, getObjId),\n    $prepare$: data => parseResourceReturn(data),\n    $fill$: (resource, getObject) => {\n        if (\"resolved\" === resource._state) {\n            resource._resolved = getObject(resource._resolved), resource.value = Promise.resolve(resource._resolved);\n        } else if (\"rejected\" === resource._state) {\n            const p = Promise.reject(resource._error);\n            p.catch((() => null)), resource._error = getObject(resource._error), resource.value = p;\n        }\n    }\n};\n\nconst URLSerializer = {\n    $prefix$: \"\u0005\",\n    $test$: v => v instanceof URL,\n    $serialize$: obj => obj.href,\n    $prepare$: data => new URL(data),\n    $fill$: void 0\n};\n\nconst DateSerializer = {\n    $prefix$: \"\u0006\",\n    $test$: v => v instanceof Date,\n    $serialize$: obj => obj.toISOString(),\n    $prepare$: data => new Date(data),\n    $fill$: void 0\n};\n\nconst RegexSerializer = {\n    $prefix$: \"\u0007\",\n    $test$: v => v instanceof RegExp,\n    $serialize$: obj => `${obj.flags} ${obj.source}`,\n    $prepare$: data => {\n        const space = data.indexOf(\" \");\n        const source = data.slice(space + 1);\n        const flags = data.slice(0, space);\n        return new RegExp(source, flags);\n    },\n    $fill$: void 0\n};\n\nconst ErrorSerializer = {\n    $prefix$: \"\u000e\",\n    $test$: v => v instanceof Error,\n    $serialize$: obj => obj.message,\n    $prepare$: text => {\n        const err = new Error(text);\n        return err.stack = void 0, err;\n    },\n    $fill$: void 0\n};\n\nconst DocumentSerializer = {\n    $prefix$: \"\u000f\",\n    $test$: v => isDocument(v),\n    $serialize$: void 0,\n    $prepare$: (_, _c, doc) => doc,\n    $fill$: void 0\n};\n\nconst SERIALIZABLE_STATE = Symbol(\"serializable-data\");\n\nconst ComponentSerializer = {\n    $prefix$: \"\u0010\",\n    $test$: obj => isQwikComponent(obj),\n    $serialize$: (obj, getObjId) => {\n        const [qrl] = obj[SERIALIZABLE_STATE];\n        return serializeQRL(qrl, {\n            $getObjId$: getObjId\n        });\n    },\n    $prepare$: (data, containerState) => {\n        const qrl = parseQRL(data, containerState.$containerEl$);\n        return componentQrl(qrl);\n    },\n    $fill$: (component, getObject) => {\n        const [qrl] = component[SERIALIZABLE_STATE];\n        qrl.$capture$ && qrl.$capture$.length > 0 && (qrl.$captureRef$ = qrl.$capture$.map(getObject), \n        qrl.$capture$ = null);\n    }\n};\n\nconst DerivedSignalSerializer = {\n    $prefix$: \"\u0011\",\n    $test$: obj => obj instanceof SignalDerived,\n    $collect$: (obj, collector, leaks) => {\n        if (obj.$args$) {\n            for (const arg of obj.$args$) {\n                collectValue(arg, collector, leaks);\n            }\n        }\n    },\n    $serialize$: (signal, getObjID, collector) => {\n        const serialized = serializeDerivedSignalFunc(signal);\n        let index = collector.$inlinedFunctions$.indexOf(serialized);\n        return index < 0 && (collector.$inlinedFunctions$.push(serialized), index = collector.$inlinedFunctions$.length - 1), \n        mapJoin(signal.$args$, getObjID, \" \") + \" @\" + intToStr(index);\n    },\n    $prepare$: data => {\n        const ids = data.split(\" \");\n        const args = ids.slice(0, -1);\n        const fn = ids[ids.length - 1];\n        return new SignalDerived(fn, args, fn);\n    },\n    $fill$: (fn, getObject) => {\n        assertString(fn.$func$, \"fn.$func$ should be a string\"), fn.$func$ = getObject(fn.$func$), \n        fn.$args$ = fn.$args$.map(getObject);\n    }\n};\n\nconst SignalSerializer = {\n    $prefix$: \"\u0012\",\n    $test$: v => v instanceof SignalImpl,\n    $collect$: (obj, collector, leaks) => {\n        collectValue(obj.untrackedValue, collector, leaks);\n        return !0 === leaks && 0 == (1 & obj[QObjectSignalFlags]) && collectSubscriptions(obj[QObjectManagerSymbol], collector, !0), \n        obj;\n    },\n    $serialize$: (obj, getObjId) => getObjId(obj.untrackedValue),\n    $prepare$: (data, containerState) => new SignalImpl(data, containerState?.$subsManager$?.$createManager$(), 0),\n    $subs$: (signal, subs) => {\n        signal[QObjectManagerSymbol].$addSubs$(subs);\n    },\n    $fill$: (signal, getObject) => {\n        signal.untrackedValue = getObject(signal.untrackedValue);\n    }\n};\n\nconst SignalWrapperSerializer = {\n    $prefix$: \"\u0013\",\n    $test$: v => v instanceof SignalWrapper,\n    $collect$(obj, collector, leaks) {\n        if (collectValue(obj.ref, collector, leaks), fastWeakSerialize(obj.ref)) {\n            const localManager = getSubscriptionManager(obj.ref);\n            isTreeShakeable(collector.$containerState$.$subsManager$, localManager, leaks) && collectValue(obj.ref[obj.prop], collector, leaks);\n        }\n        return obj;\n    },\n    $serialize$: (obj, getObjId) => `${getObjId(obj.ref)} ${obj.prop}`,\n    $prepare$: data => {\n        const [id, prop] = data.split(\" \");\n        return new SignalWrapper(id, prop);\n    },\n    $fill$: (signal, getObject) => {\n        signal.ref = getObject(signal.ref);\n    }\n};\n\nconst NoFiniteNumberSerializer = {\n    $prefix$: \"\u0014\",\n    $test$: v => \"number\" == typeof v,\n    $serialize$: v => String(v),\n    $prepare$: data => Number(data),\n    $fill$: void 0\n};\n\nconst URLSearchParamsSerializer = {\n    $prefix$: \"\u0015\",\n    $test$: v => v instanceof URLSearchParams,\n    $serialize$: obj => obj.toString(),\n    $prepare$: data => new URLSearchParams(data),\n    $fill$: void 0\n};\n\nconst FormDataSerializer = {\n    $prefix$: \"\u0016\",\n    $test$: v => \"undefined\" != typeof FormData && v instanceof globalThis.FormData,\n    $serialize$: formData => {\n        const array = [];\n        return formData.forEach(((value, key) => {\n            array.push(\"string\" == typeof value ? [ key, value ] : [ key, value.name ]);\n        })), JSON.stringify(array);\n    },\n    $prepare$: data => {\n        const array = JSON.parse(data);\n        const formData = new FormData;\n        for (const [key, value] of array) {\n            formData.append(key, value);\n        }\n        return formData;\n    },\n    $fill$: void 0\n};\n\nconst JSXNodeSerializer = {\n    $prefix$: \"\u0017\",\n    $test$: v => isJSXNode(v),\n    $collect$: (node, collector, leaks) => {\n        collectValue(node.children, collector, leaks), collectValue(node.props, collector, leaks), \n        collectValue(node.immutableProps, collector, leaks);\n        let type = node.type;\n        type === Slot ? type = \":slot\" : type === Fragment && (type = \":fragment\"), collectValue(type, collector, leaks);\n    },\n    $serialize$: (node, getObjID) => {\n        let type = node.type;\n        return type === Slot ? type = \":slot\" : type === Fragment && (type = \":fragment\"), \n        `${getObjID(type)} ${getObjID(node.props)} ${getObjID(node.immutableProps)} ${getObjID(node.children)} ${node.flags}`;\n    },\n    $prepare$: data => {\n        const [type, props, immutableProps, children, flags] = data.split(\" \");\n        return new JSXNodeImpl(type, props, immutableProps, children, parseInt(flags, 10));\n    },\n    $fill$: (node, getObject) => {\n        node.type = getResolveJSXType(getObject(node.type)), node.props = getObject(node.props), \n        node.immutableProps = getObject(node.immutableProps), node.children = getObject(node.children);\n    }\n};\n\nconst BigIntSerializer = {\n    $prefix$: \"\u0018\",\n    $test$: v => \"bigint\" == typeof v,\n    $serialize$: v => v.toString(),\n    $prepare$: data => BigInt(data),\n    $fill$: void 0\n};\n\nconst DATA = Symbol();\n\nconst SetSerializer = {\n    $prefix$: \"\u0019\",\n    $test$: v => v instanceof Set,\n    $collect$: (set, collector, leaks) => {\n        set.forEach((value => collectValue(value, collector, leaks)));\n    },\n    $serialize$: (v, getObjID) => Array.from(v).map(getObjID).join(\" \"),\n    $prepare$: data => {\n        const set = new Set;\n        return set[DATA] = data, set;\n    },\n    $fill$: (set, getObject) => {\n        const data = set[DATA];\n        set[DATA] = void 0, assertString(data, \"SetSerializer should be defined\");\n        for (const id of data.split(\" \")) {\n            set.add(getObject(id));\n        }\n    }\n};\n\nconst MapSerializer = {\n    $prefix$: \"\u001a\",\n    $test$: v => v instanceof Map,\n    $collect$: (map, collector, leaks) => {\n        map.forEach(((value, key) => {\n            collectValue(value, collector, leaks), collectValue(key, collector, leaks);\n        }));\n    },\n    $serialize$: (map, getObjID) => {\n        const result = [];\n        return map.forEach(((value, key) => {\n            result.push(getObjID(key) + \" \" + getObjID(value));\n        })), result.join(\" \");\n    },\n    $prepare$: data => {\n        const set = new Map;\n        return set[DATA] = data, set;\n    },\n    $fill$: (set, getObject) => {\n        const data = set[DATA];\n        set[DATA] = void 0, assertString(data, \"SetSerializer should be defined\");\n        const items = data.split(\" \");\n        assertTrue(items.length % 2 == 0, \"MapSerializer should have even number of items\");\n        for (let i = 0; i < items.length; i += 2) {\n            set.set(getObject(items[i]), getObject(items[i + 1]));\n        }\n    }\n};\n\nconst serializers = [ QRLSerializer, SignalSerializer, SignalWrapperSerializer, TaskSerializer, ResourceSerializer, URLSerializer, DateSerializer, RegexSerializer, ErrorSerializer, DerivedSignalSerializer, FormDataSerializer, URLSearchParamsSerializer, ComponentSerializer, NoFiniteNumberSerializer, JSXNodeSerializer, BigIntSerializer, SetSerializer, MapSerializer, DocumentSerializer ];\n\nconst collectorSerializers = /*#__PURE__*/ serializers.filter((a => a.$collect$));\n\nconst canSerialize = obj => {\n    for (const s of serializers) {\n        if (s.$test$(obj)) {\n            return !0;\n        }\n    }\n    return !1;\n};\n\nconst collectDeps = (obj, collector, leaks) => {\n    for (const s of collectorSerializers) {\n        if (s.$test$(obj)) {\n            return s.$collect$(obj, collector, leaks), !0;\n        }\n    }\n    return !1;\n};\n\nconst serializeValue = (obj, getObjID, collector, containerState) => {\n    for (const s of serializers) {\n        if (s.$test$(obj)) {\n            let value = s.$prefix$;\n            return s.$serialize$ && (value += s.$serialize$(obj, getObjID, collector, containerState)), \n            value;\n        }\n    }\n};\n\nconst createParser = (containerState, doc) => {\n    const fillMap = new Map;\n    const subsMap = new Map;\n    return {\n        prepare(data) {\n            for (const s of serializers) {\n                const prefix = s.$prefix$;\n                if (data.startsWith(prefix)) {\n                    const value = s.$prepare$(data.slice(prefix.length), containerState, doc);\n                    return s.$fill$ && fillMap.set(value, s), s.$subs$ && subsMap.set(value, s), value;\n                }\n            }\n            return data;\n        },\n        subs(obj, subs) {\n            const serializer = subsMap.get(obj);\n            return !!serializer && (serializer.$subs$(obj, subs, containerState), !0);\n        },\n        fill(obj, getObject) {\n            const serializer = fillMap.get(obj);\n            return !!serializer && (serializer.$fill$(obj, getObject, containerState), !0);\n        }\n    };\n};\n\nconst OBJECT_TRANSFORMS = {\n    \"!\": (obj, containerState) => containerState.$proxyMap$.get(obj) ?? getOrCreateProxy(obj, containerState),\n    \"~\": obj => Promise.resolve(obj),\n    _: obj => Promise.reject(obj)\n};\n\nconst isTreeShakeable = (manager, target, leaks) => {\n    if (\"boolean\" == typeof leaks) {\n        return leaks;\n    }\n    const localManager = manager.$groupToManagers$.get(leaks);\n    return !!(localManager && localManager.length > 0) && (1 !== localManager.length || localManager[0] !== target);\n};\n\nconst getResolveJSXType = type => \":slot\" === type ? Slot : \":fragment\" === type ? Fragment : type;\n\nconst verifySerializable = (value, preMessage) => {\n    const seen = new Set;\n    return _verifySerializable(value, seen, \"_\", preMessage);\n};\n\nconst _verifySerializable = (value, seen, ctx, preMessage) => {\n    const unwrapped = unwrapProxy(value);\n    if (null == unwrapped) {\n        return value;\n    }\n    if (shouldSerialize(unwrapped)) {\n        if (seen.has(unwrapped)) {\n            return value;\n        }\n        if (seen.add(unwrapped), canSerialize(unwrapped)) {\n            return value;\n        }\n        const typeObj = typeof unwrapped;\n        switch (typeObj) {\n          case \"object\":\n            if (isPromise(unwrapped)) {\n                return value;\n            }\n            if (isNode$1(unwrapped)) {\n                return value;\n            }\n            if (isArray(unwrapped)) {\n                let expectIndex = 0;\n                return unwrapped.forEach(((v, i) => {\n                    if (i !== expectIndex) {\n                        throw qError(3, unwrapped);\n                    }\n                    _verifySerializable(v, seen, ctx + \"[\" + i + \"]\"), expectIndex = i + 1;\n                })), value;\n            }\n            if (isSerializableObject(unwrapped)) {\n                for (const [key, item] of Object.entries(unwrapped)) {\n                    _verifySerializable(item, seen, ctx + \".\" + key);\n                }\n                return value;\n            }\n            break;\n\n          case \"boolean\":\n          case \"string\":\n          case \"number\":\n            return value;\n        }\n        let message = \"\";\n        if (message = preMessage || \"Value cannot be serialized\", \"_\" !== ctx && (message += ` in ${ctx},`), \n        \"object\" === typeObj) {\n            message += ` because it's an instance of \"${value?.constructor.name}\". You might need to use 'noSerialize()' or use an object literal instead. Check out https://qwik.builder.io/docs/advanced/dollar/`;\n        } else if (\"function\" === typeObj) {\n            const fnName = value.name;\n            message += ` because it's a function named \"${fnName}\". You might need to convert it to a QRL using $(fn):\\n\\nconst ${fnName} = $(${String(value)});\\n\\nPlease check out https://qwik.builder.io/docs/advanced/qrl/ for more information.`;\n        }\n        console.error(\"Trying to serialize\", value), throwErrorAndStop(message);\n    }\n    return value;\n};\n\nconst noSerializeSet = /*#__PURE__*/ new WeakSet;\n\nconst weakSerializeSet = /*#__PURE__*/ new WeakSet;\n\nconst shouldSerialize = obj => !isObject(obj) && !isFunction(obj) || !noSerializeSet.has(obj);\n\nconst fastSkipSerialize = obj => noSerializeSet.has(obj);\n\nconst fastWeakSerialize = obj => weakSerializeSet.has(obj);\n\nconst noSerialize = input => (null != input && noSerializeSet.add(input), input);\n\nconst _weakSerialize = input => (weakSerializeSet.add(input), input);\n\nconst isConnected = sub => isSubscriberDescriptor(sub) ? isConnected(sub.$el$) : !!tryGetContext(sub) || sub.isConnected;\n\nconst unwrapProxy = proxy => isObject(proxy) ? getProxyTarget(proxy) ?? proxy : proxy;\n\nconst getProxyTarget = obj => obj[QOjectTargetSymbol];\n\nconst getSubscriptionManager = obj => obj[QObjectManagerSymbol];\n\nconst getProxyFlags = obj => obj[QObjectFlagsSymbol];\n\nconst serializeSubscription = (sub, getObjId) => {\n    const type = sub[0];\n    const host = \"string\" == typeof sub[1] ? sub[1] : getObjId(sub[1]);\n    if (!host) {\n        return;\n    }\n    let base = type + \" \" + host;\n    let key;\n    if (0 === type) {\n        key = sub[2];\n    } else {\n        const signalID = getObjId(sub[2]);\n        if (!signalID) {\n            return;\n        }\n        if (type <= 2) {\n            key = sub[5], base += ` ${signalID} ${must(getObjId(sub[3]))} ${sub[4]}`;\n        } else if (type <= 4) {\n            key = sub[4];\n            base += ` ${signalID} ${\"string\" == typeof sub[3] ? sub[3] : must(getObjId(sub[3]))}`;\n        } else {\n            assertFail(\"Should not get here\");\n        }\n    }\n    return key && (base += ` ${encodeURI(key)}`), base;\n};\n\nconst parseSubscription = (sub, getObject) => {\n    const parts = sub.split(\" \");\n    const type = parseInt(parts[0], 10);\n    assertTrue(parts.length >= 2, \"At least 2 parts\");\n    const host = getObject(parts[1]);\n    if (!host) {\n        return;\n    }\n    if (isSubscriberDescriptor(host) && !host.$el$) {\n        return;\n    }\n    const subscription = [ type, host ];\n    return 0 === type ? (assertTrue(parts.length <= 3, \"Max 3 parts\"), subscription.push(safeDecode(parts[2]))) : type <= 2 ? (assertTrue(5 === parts.length || 6 === parts.length, \"Type 1 has 5\"), \n    subscription.push(getObject(parts[2]), getObject(parts[3]), parts[4], safeDecode(parts[5]))) : type <= 4 && (assertTrue(4 === parts.length || 5 === parts.length, \"Type 2 has 4\"), \n    subscription.push(getObject(parts[2]), getObject(parts[3]), safeDecode(parts[4]))), \n    subscription;\n};\n\nconst safeDecode = str => {\n    if (void 0 !== str) {\n        return decodeURI(str);\n    }\n};\n\nconst createSubscriptionManager = containerState => {\n    const groupToManagers = new Map;\n    const manager = {\n        $groupToManagers$: groupToManagers,\n        $createManager$: initialMap => new LocalSubscriptionManager(groupToManagers, containerState, initialMap),\n        $clearSub$: group => {\n            const managers = groupToManagers.get(group);\n            if (managers) {\n                for (const manager of managers) {\n                    manager.$unsubGroup$(group);\n                }\n                groupToManagers.delete(group), managers.length = 0;\n            }\n        },\n        $clearSignal$: signal => {\n            const managers = groupToManagers.get(signal[1]);\n            if (managers) {\n                for (const manager of managers) {\n                    manager.$unsubEntry$(signal);\n                }\n            }\n        }\n    };\n    return seal(), manager;\n};\n\nclass LocalSubscriptionManager {\n    constructor($groupToManagers$, $containerState$, initialMap) {\n        this.$groupToManagers$ = $groupToManagers$, this.$containerState$ = $containerState$, \n        this.$subs$ = [], initialMap && this.$addSubs$(initialMap), seal();\n    }\n    $addSubs$(subs) {\n        this.$subs$.push(...subs);\n        for (const sub of this.$subs$) {\n            this.$addToGroup$(sub[1], this);\n        }\n    }\n    $addToGroup$(group, manager) {\n        let managers = this.$groupToManagers$.get(group);\n        managers || this.$groupToManagers$.set(group, managers = []), managers.includes(manager) || managers.push(manager);\n    }\n    $unsubGroup$(group) {\n        const subs = this.$subs$;\n        for (let i = 0; i < subs.length; i++) {\n            subs[i][1] === group && (subs.splice(i, 1), i--);\n        }\n    }\n    $unsubEntry$(entry) {\n        const [type, group, signal, elm] = entry;\n        const subs = this.$subs$;\n        if (1 === type || 2 === type) {\n            const prop = entry[4];\n            for (let i = 0; i < subs.length; i++) {\n                const sub = subs[i];\n                sub[0] === type && sub[1] === group && sub[2] === signal && sub[3] === elm && sub[4] === prop && (subs.splice(i, 1), \n                i--);\n            }\n        } else if (3 === type || 4 === type) {\n            for (let i = 0; i < subs.length; i++) {\n                const sub = subs[i];\n                sub[0] === type && sub[1] === group && sub[2] === signal && sub[3] === elm && (subs.splice(i, 1), \n                i--);\n            }\n        }\n    }\n    $addSub$(sub, key) {\n        const subs = this.$subs$;\n        const group = sub[1];\n        0 === sub[0] && subs.some((([_type, _group, _key]) => 0 === _type && _group === group && _key === key)) || (subs.push([ ...sub, key ]), \n        this.$addToGroup$(group, this));\n    }\n    $notifySubs$(key) {\n        const subs = this.$subs$;\n        for (const sub of subs) {\n            const compare = sub[sub.length - 1];\n            key && compare && compare !== key || notifyChange(sub, this.$containerState$);\n        }\n    }\n}\n\nconst must = a => {\n    if (null == a) {\n        throw logError(\"must be non null\", a);\n    }\n    return a;\n};\n\nconst isQrl = value => \"function\" == typeof value && \"function\" == typeof value.getSymbol;\n\nconst createQRL = (chunk, symbol, symbolRef, symbolFn, capture, captureRef, refSymbol) => {\n    let _containerEl;\n    const qrl = async function(...args) {\n        const fn = invokeFn.call(this, tryGetInvokeContext());\n        return await fn(...args);\n    };\n    const setContainer = el => (_containerEl || (_containerEl = el), _containerEl);\n    const resolve = async containerEl => {\n        if (containerEl && setContainer(containerEl), null !== symbolRef) {\n            return symbolRef;\n        }\n        if (null !== symbolFn) {\n            return symbolRef = symbolFn().then((module => qrl.resolved = symbolRef = module[symbol]));\n        }\n        {\n            const symbol2 = getPlatform().importSymbol(_containerEl, chunk, symbol);\n            return symbolRef = then(symbol2, (ref => qrl.resolved = symbolRef = ref));\n        }\n    };\n    const resolveLazy = containerEl => null !== symbolRef ? symbolRef : resolve(containerEl);\n    function invokeFn(currentCtx, beforeFn) {\n        return (...args) => {\n            const start = now();\n            const fn = resolveLazy();\n            return then(fn, (fn => {\n                if (isFunction(fn)) {\n                    if (beforeFn && !1 === beforeFn()) {\n                        return;\n                    }\n                    const context = {\n                        ...createOrReuseInvocationContext(currentCtx),\n                        $qrl$: qrl\n                    };\n                    return void 0 === context.$event$ && (context.$event$ = this), emitUsedSymbol(symbol, context.$element$, start), \n                    invoke.call(this, context, fn, ...args);\n                }\n                throw qError(10);\n            }));\n        };\n    }\n    const createOrReuseInvocationContext = invoke => null == invoke ? newInvokeContext() : isArray(invoke) ? newInvokeContextFromTuple(invoke) : invoke;\n    const resolvedSymbol = refSymbol ?? symbol;\n    const hash = getSymbolHash(resolvedSymbol);\n    return Object.assign(qrl, {\n        getSymbol: () => resolvedSymbol,\n        getHash: () => hash,\n        getCaptured: () => captureRef,\n        resolve,\n        $resolveLazy$: resolveLazy,\n        $setContainer$: setContainer,\n        $chunk$: chunk,\n        $symbol$: symbol,\n        $refSymbol$: refSymbol,\n        $hash$: hash,\n        getFn: invokeFn,\n        $capture$: capture,\n        $captureRef$: captureRef,\n        dev: null,\n        resolved: void 0\n    }), seal(), qrl;\n};\n\nconst getSymbolHash = symbolName => {\n    const index = symbolName.lastIndexOf(\"_\");\n    return index > -1 ? symbolName.slice(index + 1) : symbolName;\n};\n\nfunction assertQrl() {\n    qDev;\n}\n\nfunction assertSignal() {\n    qDev;\n}\n\nconst EMITTED = /*#__PURE__*/ new Set;\n\nconst emitUsedSymbol = (symbol, element, reqTime) => {\n    EMITTED.has(symbol) || (EMITTED.add(symbol), emitEvent(\"qsymbol\", {\n        symbol,\n        element,\n        reqTime\n    }));\n};\n\nconst emitEvent = (eventName, detail) => {\n    isServerPlatform() || \"object\" != typeof document || document.dispatchEvent(new CustomEvent(eventName, {\n        bubbles: !1,\n        detail\n    }));\n};\n\nconst now = () => isServerPlatform() ? 0 : \"object\" == typeof performance ? performance.now() : 0;\n\nlet runtimeSymbolId = 0;\n\nconst $ = expression => createQRL(null, \"s\" + runtimeSymbolId++, expression, null, null, null, null);\n\nconst eventQrl = qrl => qrl;\n\nconst event$ = implicit$FirstArg(eventQrl);\n\nconst componentQrl = componentQrl => {\n    function QwikComponent(props, key, flags) {\n        assertQrl(componentQrl), assertNumber(flags, \"The Qwik Component was not invoked correctly\");\n        const hash = componentQrl.$hash$.slice(0, 4);\n        return _jsxC(Virtual, {\n            \"q:renderFn\": componentQrl,\n            [QSlot]: props[QSlot],\n            [_IMMUTABLE]: props[_IMMUTABLE],\n            children: props.children,\n            props\n        }, flags, hash + \":\" + (key || \"\"));\n    }\n    return QwikComponent[SERIALIZABLE_STATE] = [ componentQrl ], QwikComponent;\n};\n\nconst isQwikComponent = component => \"function\" == typeof component && void 0 !== component[SERIALIZABLE_STATE];\n\nconst component$ = onMount => componentQrl($(onMount));\n\nconst flattenArray = (array, dst) => {\n    dst || (dst = []);\n    for (const item of array) {\n        isArray(item) ? flattenArray(item, dst) : dst.push(item);\n    }\n    return dst;\n};\n\nfunction h(type, props, ...children) {\n    const normalizedProps = {\n        children: arguments.length > 2 ? flattenArray(children) : void 0\n    };\n    let key;\n    let i;\n    for (i in props) {\n        \"key\" == i ? key = props[i] : normalizedProps[i] = props[i];\n    }\n    return \"string\" == typeof type && !key && \"dangerouslySetInnerHTML\" in normalizedProps && (key = \"innerhtml\"), \n    jsx(type, normalizedProps, key);\n}\n\nconst render = async (parent, jsxNode, opts) => {\n    isJSXNode(jsxNode) || (jsxNode = jsx(jsxNode, null));\n    const doc = getDocument(parent);\n    const containerEl = getElement(parent);\n    injectQContainer(containerEl);\n    const containerState = _getContainerState(containerEl);\n    const serverData = opts?.serverData;\n    serverData && Object.assign(containerState.$serverData$, serverData);\n    const rCtx = createRenderContext(doc, containerState);\n    return containerState.$hostsRendering$ = new Set, containerState.$styleMoved$ = !0, \n    await renderRoot(rCtx, containerEl, jsxNode, doc, containerState, containerEl), \n    await postRendering(containerState, rCtx), {\n        cleanup() {\n            cleanupContainer(rCtx, containerEl);\n        }\n    };\n};\n\nconst renderRoot = async (rCtx, parent, jsxNode) => {\n    const staticCtx = rCtx.$static$;\n    try {\n        const processedNodes = await processData(jsxNode);\n        const rootJsx = domToVnode(parent);\n        await smartUpdateChildren(rCtx, rootJsx, wrapJSX(parent, processedNodes), 0);\n    } catch (err) {\n        logError(err);\n    }\n    staticCtx.$operations$.push(...staticCtx.$postOperations$), executeDOMRender(staticCtx), \n    printRenderStats();\n};\n\nconst getElement = docOrElm => isDocument(docOrElm) ? docOrElm.documentElement : docOrElm;\n\nconst injectQContainer = containerEl => {\n    directSetAttribute(containerEl, \"q:version\", \"1.2.11\"), directSetAttribute(containerEl, \"q:container\", \"resumed\"), \n    directSetAttribute(containerEl, \"q:render\", \"dom\");\n};\n\nfunction cleanupContainer(renderCtx, container) {\n    cleanupTree(container, renderCtx.$static$, renderCtx.$static$.$containerState$.$subsManager$, !0), \n    delete container[CONTAINER_STATE], directRemoveAttribute(container, \"q:version\"), \n    directRemoveAttribute(container, \"q:container\"), directRemoveAttribute(container, \"q:render\"), \n    container.replaceChildren();\n}\n\nconst useStore = (initialState, opts) => {\n    const {get, set, iCtx} = useSequentialScope();\n    if (null != get) {\n        return get;\n    }\n    const value = isFunction(initialState) ? invoke(void 0, initialState) : initialState;\n    if (!1 === opts?.reactive) {\n        return set(value), value;\n    }\n    {\n        const newStore = getOrCreateProxy(value, iCtx.$renderCtx$.$static$.$containerState$, opts?.deep ?? !0 ? 1 : 0);\n        return set(newStore), newStore;\n    }\n};\n\nconst useId = () => {\n    const {get, set, elCtx, iCtx} = useSequentialScope();\n    if (null != get) {\n        return get;\n    }\n    const containerBase = iCtx.$renderCtx$?.$static$?.$containerState$?.$base$ || \"\";\n    return set(`${containerBase ? hashCode(containerBase) : \"\"}-${elCtx.$componentQrl$?.getHash() || \"\"}-${getNextIndex(iCtx.$renderCtx$) || \"\"}`);\n};\n\nfunction useServerData(key, defaultValue) {\n    const ctx = tryGetInvokeContext();\n    return ctx?.$renderCtx$?.$static$.$containerState$.$serverData$[key] ?? defaultValue;\n}\n\nconst STYLE_CACHE = /*#__PURE__*/ new Map;\n\nconst getScopedStyles = (css, scopeId) => {\n    let styleCss = STYLE_CACHE.get(scopeId);\n    return styleCss || STYLE_CACHE.set(scopeId, styleCss = scopeStylesheet(css, scopeId)), \n    styleCss;\n};\n\nconst scopeStylesheet = (css, scopeId) => {\n    const end = css.length;\n    const out = [];\n    const stack = [];\n    let idx = 0;\n    let lastIdx = idx;\n    let mode = rule;\n    let lastCh = 0;\n    for (;idx < end; ) {\n        const chIdx = idx;\n        let ch = css.charCodeAt(idx++);\n        ch === BACKSLASH && (idx++, ch = A);\n        const arcs = STATE_MACHINE[mode];\n        for (let i = 0; i < arcs.length; i++) {\n            const arc = arcs[i];\n            const [expectLastCh, expectCh, newMode] = arc;\n            if ((expectLastCh === lastCh || expectLastCh === ANY || expectLastCh === IDENT && isIdent(lastCh) || expectLastCh === WHITESPACE && isWhiteSpace(lastCh)) && (expectCh === ch || expectCh === ANY || expectCh === IDENT && isIdent(ch) || expectCh === NOT_IDENT && !isIdent(ch) && ch !== DOT || expectCh === WHITESPACE && isWhiteSpace(ch)) && (3 == arc.length || lookAhead(arc))) {\n                if (arc.length > 3 && (ch = css.charCodeAt(idx - 1)), newMode === EXIT || newMode == EXIT_INSERT_SCOPE) {\n                    if (newMode === EXIT_INSERT_SCOPE) {\n                        if (mode !== starSelector || shouldNotInsertScoping()) {\n                            if (!isChainedSelector(ch)) {\n                                insertScopingSelector(idx - (expectCh == NOT_IDENT ? 1 : expectCh == CLOSE_PARENTHESIS ? 2 : 0));\n                            }\n                        } else {\n                            isChainedSelector(ch) ? flush(idx - 2) : insertScopingSelector(idx - 2), lastIdx++;\n                        }\n                    }\n                    expectCh === NOT_IDENT && (idx--, ch = lastCh);\n                    do {\n                        mode = stack.pop() || rule, mode === pseudoGlobal && (flush(idx - 1), lastIdx++);\n                    } while (isSelfClosingRule(mode));\n                } else {\n                    stack.push(mode), mode === pseudoGlobal && newMode === rule ? (flush(idx - 8), lastIdx = idx) : newMode === pseudoElement && insertScopingSelector(chIdx), \n                    mode = newMode;\n                }\n                break;\n            }\n        }\n        lastCh = ch;\n    }\n    return flush(idx), out.join(\"\");\n    function flush(idx) {\n        out.push(css.substring(lastIdx, idx)), lastIdx = idx;\n    }\n    function insertScopingSelector(idx) {\n        mode === pseudoGlobal || shouldNotInsertScoping() || (flush(idx), out.push(\".\", \"⭐️\", scopeId));\n    }\n    function lookAhead(arc) {\n        let prefix = 0;\n        if (css.charCodeAt(idx) === DASH) {\n            for (let i = 1; i < 10; i++) {\n                if (css.charCodeAt(idx + i) === DASH) {\n                    prefix = i + 1;\n                    break;\n                }\n            }\n        }\n        words: for (let arcIndx = 3; arcIndx < arc.length; arcIndx++) {\n            const txt = arc[arcIndx];\n            for (let i = 0; i < txt.length; i++) {\n                if ((css.charCodeAt(idx + i + prefix) | LOWERCASE) !== txt.charCodeAt(i)) {\n                    continue words;\n                }\n            }\n            return idx += txt.length + prefix, !0;\n        }\n        return !1;\n    }\n    function shouldNotInsertScoping() {\n        return -1 !== stack.indexOf(pseudoGlobal) || -1 !== stack.indexOf(atRuleSelector);\n    }\n};\n\nconst isIdent = ch => ch >= _0 && ch <= _9 || ch >= A && ch <= Z || ch >= a && ch <= z || ch >= 128 || ch === UNDERSCORE || ch === DASH;\n\nconst isChainedSelector = ch => ch === COLON || ch === DOT || ch === OPEN_BRACKET || ch === HASH || isIdent(ch);\n\nconst isSelfClosingRule = mode => mode === atRuleBlock || mode === atRuleSelector || mode === atRuleInert || mode === pseudoGlobal;\n\nconst isWhiteSpace = ch => ch === SPACE || ch === TAB || ch === NEWLINE || ch === CARRIAGE_RETURN;\n\nconst rule = 0;\n\nconst elementClassIdSelector = 1;\n\nconst starSelector = 2;\n\nconst pseudoClassWithSelector = 3;\n\nconst pseudoClass = 4;\n\nconst pseudoGlobal = 5;\n\nconst pseudoElement = 6;\n\nconst attrSelector = 7;\n\nconst inertParenthesis = 8;\n\nconst inertBlock = 9;\n\nconst atRuleSelector = 10;\n\nconst atRuleBlock = 11;\n\nconst atRuleInert = 12;\n\nconst body = 13;\n\nconst stringSingle = 14;\n\nconst stringDouble = 15;\n\nconst commentMultiline = 16;\n\nconst EXIT = 17;\n\nconst EXIT_INSERT_SCOPE = 18;\n\nconst ANY = 0;\n\nconst IDENT = 1;\n\nconst NOT_IDENT = 2;\n\nconst WHITESPACE = 3;\n\nconst TAB = 9;\n\nconst NEWLINE = 10;\n\nconst CARRIAGE_RETURN = 13;\n\nconst SPACE = 32;\n\nconst DOUBLE_QUOTE = 34;\n\nconst HASH = 35;\n\nconst SINGLE_QUOTE = 39;\n\nconst OPEN_PARENTHESIS = 40;\n\nconst CLOSE_PARENTHESIS = 41;\n\nconst STAR = 42;\n\nconst DASH = 45;\n\nconst DOT = 46;\n\nconst FORWARD_SLASH = 47;\n\nconst _0 = 48;\n\nconst _9 = 57;\n\nconst COLON = 58;\n\nconst SEMICOLON = 59;\n\nconst AT = 64;\n\nconst A = 65;\n\nconst Z = 90;\n\nconst OPEN_BRACKET = 91;\n\nconst CLOSE_BRACKET = 93;\n\nconst BACKSLASH = 92;\n\nconst UNDERSCORE = 95;\n\nconst LOWERCASE = 32;\n\nconst a = 97;\n\nconst z = 122;\n\nconst OPEN_BRACE = 123;\n\nconst CLOSE_BRACE = 125;\n\nconst STRINGS_COMMENTS = [ [ ANY, 39, 14 ], [ ANY, 34, 15 ], [ ANY, 47, 16, \"*\" ] ];\n\nconst STATE_MACHINE = [ [ [ ANY, 42, starSelector ], [ ANY, OPEN_BRACKET, 7 ], [ ANY, COLON, pseudoElement, \":\", \"before\", \"after\", \"first-letter\", \"first-line\" ], [ ANY, COLON, pseudoGlobal, \"global\" ], [ ANY, COLON, 3, \"has\", \"host-context\", \"not\", \"where\", \"is\", \"matches\", \"any\" ], [ ANY, COLON, 4 ], [ ANY, IDENT, 1 ], [ ANY, DOT, 1 ], [ ANY, HASH, 1 ], [ ANY, 64, atRuleSelector, \"keyframe\" ], [ ANY, 64, atRuleBlock, \"media\", \"supports\" ], [ ANY, 64, atRuleInert ], [ ANY, 123, 13 ], [ 47, 42, 16 ], [ ANY, 59, EXIT ], [ ANY, 125, EXIT ], [ ANY, CLOSE_PARENTHESIS, EXIT ], ...STRINGS_COMMENTS ], [ [ ANY, NOT_IDENT, EXIT_INSERT_SCOPE ] ], [ [ ANY, NOT_IDENT, EXIT_INSERT_SCOPE ] ], [ [ ANY, 40, rule ], [ ANY, NOT_IDENT, EXIT_INSERT_SCOPE ] ], [ [ ANY, 40, 8 ], [ ANY, NOT_IDENT, EXIT_INSERT_SCOPE ] ], [ [ ANY, 40, rule ], [ ANY, NOT_IDENT, EXIT ] ], [ [ ANY, NOT_IDENT, EXIT ] ], [ [ ANY, 93, EXIT_INSERT_SCOPE ], [ ANY, 39, 14 ], [ ANY, 34, 15 ] ], [ [ ANY, CLOSE_PARENTHESIS, EXIT ], ...STRINGS_COMMENTS ], [ [ ANY, 125, EXIT ], ...STRINGS_COMMENTS ], [ [ ANY, 125, EXIT ], [ WHITESPACE, IDENT, 1 ], [ ANY, COLON, pseudoGlobal, \"global\" ], [ ANY, 123, 13 ], ...STRINGS_COMMENTS ], [ [ ANY, 123, rule ], [ ANY, 59, EXIT ], ...STRINGS_COMMENTS ], [ [ ANY, 59, EXIT ], [ ANY, 123, 9 ], ...STRINGS_COMMENTS ], [ [ ANY, 125, EXIT ], [ ANY, 123, 13 ], [ ANY, 40, 8 ], ...STRINGS_COMMENTS ], [ [ ANY, 39, EXIT ] ], [ [ ANY, 34, EXIT ] ], [ [ 42, 47, EXIT ] ] ];\n\nconst useStylesQrl = styles => {\n    _useStyles(styles, (str => str), !1);\n};\n\nconst useStyles$ = /*#__PURE__*/ implicit$FirstArg(useStylesQrl);\n\nconst useStylesScopedQrl = styles => ({\n    scopeId: \"⭐️\" + _useStyles(styles, getScopedStyles, !0)\n});\n\nconst useStylesScoped$ = /*#__PURE__*/ implicit$FirstArg(useStylesScopedQrl);\n\nconst _useStyles = (styleQrl, transform, scoped) => {\n    assertQrl(styleQrl);\n    const {get, set, iCtx, i, elCtx} = useSequentialScope();\n    if (get) {\n        return get;\n    }\n    const styleId = (index = i, assertQrl(qStyles = styleQrl), `${hashCode(qStyles.$hash$)}-${index}`);\n    var qStyles, index;\n    const containerState = iCtx.$renderCtx$.$static$.$containerState$;\n    if (set(styleId), elCtx.$appendStyles$ || (elCtx.$appendStyles$ = []), elCtx.$scopeIds$ || (elCtx.$scopeIds$ = []), \n    scoped && elCtx.$scopeIds$.push(styleContent(styleId)), containerState.$styleIds$.has(styleId)) {\n        return styleId;\n    }\n    containerState.$styleIds$.add(styleId);\n    const value = styleQrl.$resolveLazy$(containerState.$containerEl$);\n    const appendStyle = styleText => {\n        assertDefined(elCtx.$appendStyles$, \"appendStyles must be defined\"), elCtx.$appendStyles$.push({\n            styleId,\n            content: transform(styleText, styleId)\n        });\n    };\n    return isPromise(value) ? iCtx.$waitOn$.push(value.then(appendStyle)) : appendStyle(value), \n    styleId;\n};\n\nconst useSignal = initialState => {\n    const {get, set, iCtx} = useSequentialScope();\n    if (null != get) {\n        return get;\n    }\n    const containerState = iCtx.$renderCtx$.$static$.$containerState$;\n    const value = isFunction(initialState) && !isQwikComponent(initialState) ? invoke(void 0, initialState) : initialState;\n    return set(_createSignal(value, containerState, 0, void 0));\n};\n\nconst useErrorBoundary = () => {\n    const store = useStore({\n        error: void 0\n    });\n    return useOn(\"error-boundary\", qrl(\"/runtime\", \"error\", [ store ])), useContextProvider(ERROR_CONTEXT, store), \n    store;\n};\n\nexport { $, Fragment, HTMLFragment, RenderOnce, Resource, SSRComment, SSRHint, SSRRaw, SSRStream, SSRStreamBlock, SkipRender, Slot, _IMMUTABLE, _deserializeData, _fnSignal, _getContextElement, _getContextEvent, _hW, _jsxBranch, _jsxC, _jsxQ, _jsxS, _noopQrl, _pauseFromContexts, _regSymbol, _renderSSR, _restProps, _serializeData, verifySerializable as _verifySerializable, _waitUntilRendered, _weakSerialize, _wrapProp, _wrapSignal, component$, componentQrl, createContextId, h as createElement, event$, eventQrl, getLocale, getPlatform, h, implicit$FirstArg, inlinedQrl, inlinedQrlDEV, jsx, jsxDEV, jsx as jsxs, noSerialize, qrl, qrlDEV, render, setPlatform, untrack, useComputed$, useComputedQrl, useContext, useContextProvider, useErrorBoundary, useId, useLexicalScope, useOn, useOnDocument, useOnWindow, useResource$, useResourceQrl, useServerData, useSignal, useStore, useStyles$, useStylesQrl, useStylesScoped$, useStylesScopedQrl, useTask$, useTaskQrl, useVisibleTask$, useVisibleTaskQrl, version, withLocale };\n",
      "start": 1696585308869,
      "end": 1696585308902,
      "sourcemaps": null
    },
    {
      "name": "astro:build",
      "start": 1696585308902,
      "end": 1696585308902,
      "order": "pre"
    },
    {
      "name": "astro:vite-plugin-env",
      "start": 1696585308902,
      "end": 1696585308902,
      "order": "pre"
    },
    {
      "name": "astro:jsx",
      "start": 1696585308902,
      "end": 1696585308902,
      "order": "pre"
    },
    {
      "name": "astro:content-asset-propagation",
      "start": 1696585308902,
      "end": 1696585308902,
      "order": "pre"
    },
    {
      "name": "vite-plugin-qwik",
      "start": 1696585308902,
      "end": 1696585308902,
      "order": "pre"
    },
    {
      "name": "vite-plugin-qwik",
      "start": 1696585308902,
      "end": 1696585308902,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1696585308902,
      "end": 1696585308902,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1696585308902,
      "end": 1696585308902,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1696585308902,
      "end": 1696585308902,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1696585308902,
      "end": 1696585308902,
      "order": "normal"
    },
    {
      "name": "astro:html",
      "start": 1696585308902,
      "end": 1696585308902,
      "order": "normal"
    },
    {
      "name": "astro:postprocess",
      "start": 1696585308902,
      "end": 1696585308902,
      "order": "normal"
    },
    {
      "name": "astro:head-metadata",
      "start": 1696585308902,
      "end": 1696585308902,
      "order": "normal"
    },
    {
      "name": "astro:content-imports",
      "start": 1696585308902,
      "end": 1696585308902,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1696585308902,
      "end": 1696585308903,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1696585308903,
      "end": 1696585308903,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1696585308903,
      "end": 1696585308903,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1696585308903,
      "end": 1696585308903,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1696585308903,
      "end": 1696585308903,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1696585308903,
      "end": 1696585308903,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1696585308903,
      "end": 1696585308903,
      "order": "normal"
    },
    {
      "name": "astro:scripts:page-ssr",
      "start": 1696585308903,
      "end": 1696585308903,
      "order": "post"
    },
    {
      "name": "astro:scanner",
      "start": 1696585308903,
      "end": 1696585308903,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1696585308903,
      "end": 1696585308906,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1696585308906,
      "end": 1696585308906,
      "order": "normal"
    }
  ]
}
